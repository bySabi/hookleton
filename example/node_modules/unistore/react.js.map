{"version":3,"file":"react.js","sources":["src/util.js","src/integrations/react.js"],"sourcesContent":["// Bind an object/factory of actions to the store and wrap them.\nexport function mapActions(actions, store) {\n\tif (typeof actions==='function') actions = actions(store);\n\tlet mapped = {};\n\tfor (let i in actions) {\n\t\tmapped[i] = store.action(actions[i]);\n\t}\n\treturn mapped;\n}\n\n\n// select('foo,bar') creates a function of the form: ({ foo, bar }) => ({ foo, bar })\nexport function select(properties) {\n\tif (typeof properties==='string') properties = properties.split(/\\s*,\\s*/);\n\treturn state => {\n\t\tlet selected = {};\n\t\tfor (let i=0; i<properties.length; i++) {\n\t\t\tselected[properties[i]] = state[properties[i]];\n\t\t}\n\t\treturn selected;\n\t};\n}\n\n\n// Lighter Object.assign stand-in\nexport function assign(obj, props) {\n\tfor (let i in props) obj[i] = props[i];\n\treturn obj;\n}\n","import { createElement, Children, Component } from 'react';\nimport { assign, mapActions, select } from '../util';\n\nconst CONTEXT_TYPES = {\n\tstore: () => {}\n};\n\n/** Wire a component up to the store. Passes state as props, re-renders on change.\n *  @param {Function|Array|String} mapStateToProps  A function mapping of store state to prop values, or an array/CSV of properties to map.\n *  @param {Function|Object} [actions] \t\t\t\tAction functions (pure state mappings), or a factory returning them. Every action function gets current state as the first parameter and any other params next\n *  @returns {Component} ConnectedComponent\n *  @example\n *    const Foo = connect('foo,bar')( ({ foo, bar }) => <div /> )\n *  @example\n *    const actions = { someAction }\n *    const Foo = connect('foo,bar', actions)( ({ foo, bar, someAction }) => <div /> )\n *  @example\n *    @connect( state => ({ foo: state.foo, bar: state.bar }) )\n *    export class Foo { render({ foo, bar }) { } }\n */\nexport function connect(mapStateToProps, actions) {\n\tif (typeof mapStateToProps!=='function') {\n\t\tmapStateToProps = select(mapStateToProps || []);\n\t}\n\treturn Child => {\n\t\tfunction Wrapper(props, context) {\n\t\t\tComponent.call(this, props, context);\n\t\t\tlet { store } = context;\n\t\t\tlet state = mapStateToProps(store ? store.getState() : {}, props);\n\t\t\tlet boundActions = actions ? mapActions(actions, store) : { store };\n\t\t\tlet update = () => {\n\t\t\t\tlet mapped = mapStateToProps(store ? store.getState() : {}, this.props);\n\t\t\t\tfor (let i in mapped) if (mapped[i]!==state[i]) {\n\t\t\t\t\tstate = mapped;\n\t\t\t\t\treturn this.forceUpdate();\n\t\t\t\t}\n\t\t\t\tfor (let i in state) if (!(i in mapped)) {\n\t\t\t\t\tstate = mapped;\n\t\t\t\t\treturn this.forceUpdate();\n\t\t\t\t}\n\t\t\t};\n\t\t\tthis.componentWillReceiveProps = update;\n\t\t\tthis.componentDidMount = () => {\n\t\t\t\tstore.subscribe(update);\n\t\t\t};\n\t\t\tthis.componentWillUnmount = () => {\n\t\t\t\tstore.unsubscribe(update);\n\t\t\t};\n\t\t\tthis.render = () => createElement(Child, assign(assign(assign({}, boundActions), this.props), state));\n\t\t}\n\t\tWrapper.contextTypes = CONTEXT_TYPES;\n\t\treturn (Wrapper.prototype = Object.create(Component.prototype)).constructor = Wrapper;\n\t};\n}\n\n\n/** Provider exposes a store (passed as `props.store`) into context.\n *\n *  Generally, an entire application is wrapped in a single `<Provider>` at the root.\n *  @class\n *  @extends Component\n *  @param {Object} props\n *  @param {Store} props.store\t\tA {Store} instance to expose via context.\n */\nexport class Provider extends Component {\n\tgetChildContext() {\n\t\treturn { store: this.props.store };\n\t}\n\trender() {\n\t\treturn Children.only(this.props.children);\n\t}\n}\nProvider.childContextTypes = CONTEXT_TYPES;\n"],"names":["assign","obj","props","let","i","const","CONTEXT_TYPES","store","Provider","getChildContext","this","render","Children","only","children","Component","childContextTypes","mapStateToProps","actions","properties","split","state","selected","length","Child","Wrapper","context","call","getState","boundActions","mapped","action","mapActions","update","forceUpdate","componentWillReceiveProps","componentDidMount","subscribe","componentWillUnmount","unsubscribe","createElement","contextTypes","prototype","Object","create","constructor"],"mappings":"uBAyBA,SAAgBA,EAAOC,EAAKC,GAC3B,IAAKC,IAAIC,KAAKF,EAAOD,EAAIG,GAAKF,EAAME,GACpC,OAAOH,ECxBRI,IAAMC,GACLC,oBA4DD,IAAaC,mJACZC,2BACC,OAASF,MAAOG,KAAKR,MAAMK,oBAE5BI,kBACC,OAAOC,WAASC,KAAKH,KAAKR,MAAMY,cALJC,aAQ9BP,EAASQ,kBAAoBV,kBApD7B,SAAwBW,EAAiBC,GDRzC,IAAuBC,ECYtB,MAH6B,mBAAlBF,IDRa,iBADFE,ECUIF,SDTQE,EAAaA,EAAWC,MAAM,YCS/DH,WDRMI,GAEN,IADAlB,IAAImB,KACKlB,EAAE,EAAGA,EAAEe,EAAWI,OAAQnB,IAClCkB,EAASH,EAAWf,IAAMiB,EAAMF,EAAWf,IAE5C,OAAOkB,aCKDE,GACN,SAASC,EAAQvB,EAAOwB,cACvBX,YAAUY,KAAKjB,KAAMR,EAAOwB,GAC5B,IAAMnB,UACFc,EAAQJ,EAAgBV,EAAQA,EAAMqB,cAAiB1B,GACvD2B,EAAeX,ED5Bf,SAAoBA,EAASX,GACd,mBAAVW,IAAsBA,EAAUA,EAAQX,IACnDJ,IAAI2B,KACJ,IAAK3B,IAAIC,KAAKc,EACbY,EAAO1B,GAAKG,EAAMwB,OAAOb,EAAQd,IAElC,OAAO0B,ECsBwBE,CAAWd,EAASX,UAAWA,GACxD0B,aACH9B,IAAI2B,EAASb,EAAgBV,EAAQA,EAAMqB,cAAiBlB,EAAKR,OACjE,IAAKC,IAAIC,KAAK0B,EAAQ,GAAIA,EAAO1B,KAAKiB,EAAMjB,GAE3C,OADAiB,EAAQS,EACDpB,EAAKwB,cAEb,IAAK/B,IAAIC,KAAKiB,EAAO,KAAMjB,KAAK0B,GAE/B,OADAT,EAAQS,EACDpB,EAAKwB,eAGdxB,KAAKyB,0BAA4BF,EACjCvB,KAAK0B,6BACJ7B,EAAM8B,UAAUJ,IAEjBvB,KAAK4B,gCACJ/B,EAAMgC,YAAYN,IAEnBvB,KAAKC,yBAAe6B,gBAAchB,EAAOxB,EAAOA,EAAOA,KAAW6B,GAAenB,EAAKR,OAAQmB,KAG/F,OADAI,EAAQgB,aAAenC,GACfmB,EAAQiB,UAAYC,OAAOC,OAAO7B,YAAU2B,YAAYG,YAAcpB"}