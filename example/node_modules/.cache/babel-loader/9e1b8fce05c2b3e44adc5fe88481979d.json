{"ast":null,"code":"import _typeof from \"@babel/runtime-corejs2/helpers/esm/typeof\";\nimport _toConsumableArray from \"@babel/runtime-corejs2/helpers/esm/toConsumableArray\";\nimport _slicedToArray from \"@babel/runtime-corejs2/helpers/esm/slicedToArray\";\nimport _Array$isArray from \"@babel/runtime-corejs2/core-js/array/is-array\";\nimport _Map from \"@babel/runtime-corejs2/core-js/map\";\nimport { useEffect, useMemo, useRef, useState } from 'react';\nexport function createHookleton(useHook) {\n  for (var _len = arguments.length, initialArgs = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    initialArgs[_key - 1] = arguments[_key];\n  }\n\n  return createHookletonWithConfig.apply(void 0, [{}, useHook].concat(initialArgs));\n}\nexport function createHookletonWithConfig() {\n  var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  var useHook = arguments.length > 1 ? arguments[1] : undefined;\n\n  for (var _len2 = arguments.length, initialArgs = new Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {\n    initialArgs[_key2 - 2] = arguments[_key2];\n  }\n\n  // config defaults\n  var useSlave = config.useSlave || useState; // inject hook for, Ex: debugging\n\n  var useRenderAll = config.renderAllHook || useEffect; // could be: ( useEffect | useLayoutEffect | use??? )\n\n  var unmountedSingleton = config.unmountedSingleton || unmountedSingletonWarn;\n  var hookOut;\n  var slaves = new _Map();\n\n  var _renderSlaves = function renderSlaves() {\n    // skip first(unexpected) 'useRenderAll' callback call\n    _renderSlaves = function renderSlaves(s) {\n      return slaves.forEach(function (updater) {\n        return updater(s);\n      });\n    };\n  };\n\n  var setPredicate = function setPredicate(u) {\n    return function (p) {\n      return slaves.set(u, withPredicate(u, p));\n    };\n  };\n\n  var isReadyMaster = false; // 'master' initialized status\n  // Custom React Hook\n\n  var hookFn = function hookFn(predicate) {\n    // Initialize 'master' and 'slaves'\n    var isPredicate = useRef(false);\n    var isMaster = useRef(false);\n    useMemo(function () {\n      if (!isMaster.current) {\n        if (!isReadyMaster) {\n          isMaster.current = true;\n          isReadyMaster = true;\n        } else {\n          isPredicate.current = typeof predicate === 'function' || typeof predicate === 'boolean';\n        }\n      }\n    }, []);\n\n    if (isMaster.current) {\n      // Update state, only 'master' can\n      hookOut = useHook.apply(void 0, initialArgs); // state = hookOut[0] | updater = hookOut[1]\n      // Checked on first 'master' render\n\n      useMemo(function () {\n        if (!_Array$isArray(hookOut)) {\n          throw new Error(\"[Hookleton] provided 'useHook' must return array values\");\n        }\n      }, []); // prevent Exception on 'master' unmount\n\n      useEffect(function () {\n        return function () {\n          return hookOut[1] = unmountedSingleton;\n        };\n      }, []); // Force render 'slaves' when state has changed\n\n      useRenderAll(function () {\n        return _renderSlaves(hookOut[0]);\n      }, [hookOut[0]]);\n      return hookOut;\n    } // is a Slave\n\n\n    var _useSlave = useSlave(),\n        _useSlave2 = _slicedToArray(_useSlave, 2),\n        updater = _useSlave2[1]; // save updater for later force render 'slaves'\n\n\n    if (!isPredicate.current) {\n      // ON mount|unmount\n      useEffect(function () {\n        slaves.set(updater, withoutPredicate(updater));\n        return function () {\n          return slaves.remove(updater);\n        };\n      }, []);\n      return hookOut; // if not Predicated return shared hookOut\n    } // Is a Predicate\n    /// ON mount|unmount\n\n\n    useEffect(function () {\n      slaves.set(updater, withPredicate(updater, predicate));\n      return function () {\n        return slaves.remove(updater);\n      };\n    }, []); // If slave is Predicated we return a cloned hookOut with a custom setPredicate\n\n    return [].concat(_toConsumableArray(hookOut), [setPredicate(updater)]);\n  }; // Inject 'geState' and 'updater' to Hook function object for standalone use, Ex: outside of a Component\n\n\n  hookFn.getState = function () {\n    return hookOut[0];\n  };\n\n  hookFn.updater = function () {\n    return hookOut[1];\n  }; /// HEREEE!!!  we need a check\n\n\n  return hookFn;\n} // Prevent a Exception get throwed when someone is trying to update a unmounted 'master',\n// behaviour can be changed with `unmountedSingleton` config setting\n\nfunction unmountedSingletonWarn() {\n  console.warn(\"[Hookleton] it's unmounted\");\n}\n\nfunction withoutPredicate(updater) {\n  return function () {\n    return updater(function (u) {\n      return ~u;\n    });\n  };\n} // Create a predicated updater\n\n\nfunction withPredicate(updater, p) {\n  var predicate = validPredicate(p); //return s => predicate(s) && updater(u => ~u);\n\n  return function (s) {\n    return inject(predicate, s) && updater(function (u) {\n      return ~u;\n    });\n  };\n}\n\nfunction inject(f, s) {\n  console.log('f:', f, ' s:', s);\n  var a = f(s);\n  console.log(a);\n  return a;\n}\n\nfunction validPredicate(p) {\n  switch (_typeof(p)) {\n    case 'undefined':\n      return TRUEFN;\n\n    case 'function':\n      return p;\n\n    case 'boolean':\n      return function () {\n        return p;\n      };\n\n    default:\n      console.warn(\"[Hookleton] predicate '\" + p + \"' is not boolean or function\");\n      return FALSEFN;\n  }\n}\n\nvar TRUEFN = function TRUEFN() {\n  return true;\n};\n\nvar FALSEFN = function FALSEFN() {\n  return false;\n};","map":{"version":3,"sources":["/Users/flx/Dropbox/Projects/hookleton/example/component/index.js"],"names":["useEffect","useMemo","useRef","useState","createHookleton","useHook","initialArgs","createHookletonWithConfig","config","useSlave","useRenderAll","renderAllHook","unmountedSingleton","unmountedSingletonWarn","hookOut","slaves","renderSlaves","s","forEach","updater","setPredicate","u","p","set","withPredicate","isReadyMaster","hookFn","predicate","isPredicate","isMaster","current","Error","withoutPredicate","remove","getState","console","warn","validPredicate","inject","f","log","a","TRUEFN","FALSEFN"],"mappings":"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","sourcesContent":["import { useEffect, useMemo, useRef, useState } from 'react';\n\nexport function createHookleton(useHook, ...initialArgs) {\n  return createHookletonWithConfig({}, useHook, ...initialArgs);\n}\n\nexport function createHookletonWithConfig(config = {}, useHook, ...initialArgs) {\n  // config defaults\n  const useSlave = config.useSlave || useState; // inject hook for, Ex: debugging\n  const useRenderAll = config.renderAllHook || useEffect; // could be: ( useEffect | useLayoutEffect | use??? )\n  const unmountedSingleton = config.unmountedSingleton || unmountedSingletonWarn;\n\n  let hookOut;\n  const slaves = new Map();\n\n  let renderSlaves = () => {\n    // skip first(unexpected) 'useRenderAll' callback call\n    renderSlaves = s => slaves.forEach(updater => updater(s));\n  };\n  const setPredicate = u => p => slaves.set(u, withPredicate(u, p));\n\n  let isReadyMaster = false; // 'master' initialized status\n\n  // Custom React Hook\n  const hookFn = predicate => {\n    // Initialize 'master' and 'slaves'\n    const isPredicate = useRef(false);\n    const isMaster = useRef(false);\n    useMemo(() => {\n      if (!isMaster.current) {\n        if (!isReadyMaster) {\n          isMaster.current = true;\n          isReadyMaster = true;\n        } else {\n          isPredicate.current = \n            typeof predicate === 'function' || typeof predicate === 'boolean';\n        }\n      }\n    }, []);\n    \n    if (isMaster.current) {\n      // Update state, only 'master' can\n      hookOut = useHook(...initialArgs); // state = hookOut[0] | updater = hookOut[1]\n\n      // Checked on first 'master' render\n      useMemo(() => {\n        if (!Array.isArray(hookOut)) {\n          throw new Error(\"[Hookleton] provided 'useHook' must return array values\");\n        }\n      }, []);\n\n      // prevent Exception on 'master' unmount\n      useEffect(() => () => (hookOut[1] = unmountedSingleton), []);\n\n      // Force render 'slaves' when state has changed\n      useRenderAll(() => renderSlaves(hookOut[0]), [hookOut[0]]);\n\n      return hookOut;\n    }\n\n    // is a Slave\n    const [, updater] = useSlave(); // save updater for later force render 'slaves'\n    \n    if (!isPredicate.current) {\n      // ON mount|unmount\n      useEffect(() => {\n        slaves.set(updater, withoutPredicate(updater));\n        return () => slaves.remove(updater);\n      }, []);\n\n      return hookOut;  // if not Predicated return shared hookOut\n    }\n\n    // Is a Predicate\n    /// ON mount|unmount\n    useEffect(() => {\n      slaves.set(updater, withPredicate(updater, predicate));\n      return () => slaves.remove(updater);\n    }, []);\n    \n    // If slave is Predicated we return a cloned hookOut with a custom setPredicate\n    return [...hookOut, setPredicate(updater)];\n  };\n\n  // Inject 'geState' and 'updater' to Hook function object for standalone use, Ex: outside of a Component\n  hookFn.getState = () => hookOut[0];\n  hookFn.updater = () => hookOut[1]; /// HEREEE!!!  we need a check\n\n  return hookFn;\n}\n\n// Prevent a Exception get throwed when someone is trying to update a unmounted 'master',\n// behaviour can be changed with `unmountedSingleton` config setting\nfunction unmountedSingletonWarn() {\n  console.warn(\"[Hookleton] it's unmounted\");\n}\n\nfunction withoutPredicate(updater) {\n  return () => updater(u => ~u);\n}\n\n// Create a predicated updater\nfunction withPredicate(updater, p) {\n  const predicate = validPredicate(p);\n  //return s => predicate(s) && updater(u => ~u);\n  return s => inject(predicate, s) && updater(u => ~u);\n}\n\nfunction inject(f, s) {\n  console.log('f:', f, ' s:', s);\n  const a = f(s)\n  console.log(a)\n  return a\n}\n\nfunction validPredicate(p) {\n  switch (typeof p) {\n    case 'undefined':\n      return TRUEFN;\n    case 'function':\n      return p;\n    case 'boolean':\n      return () => p;\n    default:\n      console.warn(\"[Hookleton] predicate '\" + p + \"' is not boolean or function\");\n      return FALSEFN;\n  }\n}\n\nconst TRUEFN = () => true;\nconst FALSEFN = () => false;\n"]},"metadata":{},"sourceType":"module"}