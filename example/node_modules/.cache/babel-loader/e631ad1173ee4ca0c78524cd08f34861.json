{"ast":null,"code":"import _slicedToArray from \"@babel/runtime-corejs2/helpers/esm/slicedToArray\";\nimport _Array$isArray from \"@babel/runtime-corejs2/core-js/array/is-array\";\nimport _toConsumableArray from \"@babel/runtime-corejs2/helpers/esm/toConsumableArray\";\nimport _Map from \"@babel/runtime-corejs2/core-js/map\";\nimport _classCallCheck from \"@babel/runtime-corejs2/helpers/esm/classCallCheck\";\nimport _createClass from \"@babel/runtime-corejs2/helpers/esm/createClass\";\nimport { useEffect, useMemo, useRef, useState } from 'react';\nexport default function createHook(useHook) {\n  for (var _len = arguments.length, initialArgs = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    initialArgs[_key - 1] = arguments[_key];\n  }\n\n  var hook = new Hookleton(useHook, initialArgs);\n  var useFn = hook.useFn.bind(hook);\n  useFn.get = hook._get.bind(hook);\n  return useFn;\n}\nexport var Hookleton =\n/*#__PURE__*/\nfunction () {\n  function Hookleton(useHook, initialArgs) {\n    _classCallCheck(this, Hookleton);\n\n    this.useHook = useHook;\n    this.args = initialArgs;\n    this.hookOut = [];\n    this.slaves = new _Map();\n  }\n\n  _createClass(Hookleton, [{\n    key: \"useFn\",\n    value: function useFn() {\n      var _this = this;\n\n      // Initialize 'master' and 'slaves'\n      var isMaster = useRef(false);\n      useMemo(function () {\n        return _this._onInit(isMaster);\n      }, []); // only one `useFn` instance will be true, 'the master'\n\n      for (var _len2 = arguments.length, initial = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        initial[_key2] = arguments[_key2];\n      }\n\n      if (isMaster.current) {\n        // Update state, only 'master' can\n        // by **CONVENTION** state is `hookOut[0]` and updater is `hookOut[1].\n        // `useHook` must follow this convetion or will fail miserably\n        this.hookOut = this.useHook.apply(this, _toConsumableArray(this.args)); // Checked only on first 'master' render\n\n        useMemo(function () {\n          if (!_Array$isArray(_this.hookOut)) {\n            throw new Error(\"[Hookleton] provided 'useHook' must return array values\");\n          }\n        }, []); // prevent Exception on 'master' unmount\n\n        useEffect(function () {\n          return function () {\n            return _this.hookOut[1] = _this.unmountedSingleton;\n          };\n        }, []); // Update 'slaves' when state changed\n\n        return this.useOnStateChange(initial);\n      }\n\n      return this.useOnSlaveRender(initial);\n    } // Here we use a custom function `updateSlaves` that ignore first render call.\n\n  }, {\n    key: \"useOnStateChange\",\n    value: function useOnStateChange() {\n      useEffect(this.__updateSlaves.bind(this), [this.hookOut[0]]);\n      return this.hookOut;\n    }\n  }, {\n    key: \"useOnSlaveRender\",\n    value: function useOnSlaveRender() {\n      var _this2 = this;\n\n      // Get slave 'updater' for, later, force render it.\n      // Slave state is ignore because we have only one state set in 'master\n      var _useState = useState(),\n          _useState2 = _slicedToArray(_useState, 2),\n          updater = _useState2[1];\n\n      useEffect(function () {\n        // a Map of key/value: updater/updater is useful for some kinds of hooks composed on top of `useFn`\n        _this2.slaves.set(updater, wrapUpdater(updater));\n\n        return function () {\n          return _this2.slaves.delete(updater);\n        }; // on unmount\n      }, []);\n      return this.hookOut;\n    }\n  }, {\n    key: \"_onInit\",\n    value: function _onInit(isMaster) {\n      this._onInit = function () {};\n\n      isMaster.current = true;\n    }\n  }, {\n    key: \"_updateSlaves\",\n    value: function _updateSlaves() {\n      var _this3 = this;\n\n      // State, `hookOut[0]`, is passed to slaves updater. This value is not use here,\n      // but could be useful for libs that extends Hookleton\n      this.slaves.forEach(function (updater) {\n        return updater(_this3.hookOut[0]);\n      });\n    }\n  }, {\n    key: \"__updateSlaves\",\n    value: function __updateSlaves() {\n      // skip first(unexpected) callback call\n      this.__updateSlaves = this._updateSlaves;\n    }\n  }, {\n    key: \"_get\",\n    value: function _get() {\n      return this.hookOut;\n    } // Prevent a Exception get throwed when someone is trying to update a unmounted 'master',\n    // behaviour can be changed with `unmountedSingleton` config setting\n\n  }, {\n    key: \"unmountedSingleton\",\n    value: function unmountedSingleton() {\n      console.warn(\"[Hookleton] Singleton it's unmounted\");\n    }\n  }]);\n\n  return Hookleton;\n}(); // slaves are updated negating '~' his current state. This force to rerender it\n\nvar wrapUpdater = function wrapUpdater(updater) {\n  return function () {\n    return updater(forceUpdate);\n  };\n};\n\nvar forceUpdate = function forceUpdate(s) {\n  return ~s;\n};","map":{"version":3,"sources":["/Users/flx/Dropbox/Projects/hookleton/example/component/index.js"],"names":["useEffect","useMemo","useRef","useState","createHook","useHook","initialArgs","hook","Hookleton","useFn","bind","get","_get","args","hookOut","slaves","isMaster","_onInit","initial","current","Error","unmountedSingleton","useOnStateChange","useOnSlaveRender","__updateSlaves","updater","set","wrapUpdater","delete","forEach","_updateSlaves","console","warn","forceUpdate","s"],"mappings":"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","sourcesContent":["import { useEffect, useMemo, useRef, useState } from 'react';\n\nexport default function createHook(useHook, ...initialArgs) {\n  const hook = new Hookleton(useHook, initialArgs);\n  const useFn = hook.useFn.bind(hook);\n  useFn.get = hook._get.bind(hook);\n  return useFn;\n}\n\nexport class Hookleton {\n  constructor(useHook, initialArgs) {\n    this.useHook = useHook;\n    this.args = initialArgs;\n\n    this.hookOut = [];\n    this.slaves = new Map();\n  }\n\n  useFn(...initial) {\n    // Initialize 'master' and 'slaves'\n    const isMaster = useRef(false);\n    useMemo(() => this._onInit(isMaster), []); // only one `useFn` instance will be true, 'the master'\n\n    if (isMaster.current) {\n      // Update state, only 'master' can\n      // by **CONVENTION** state is `hookOut[0]` and updater is `hookOut[1].\n      // `useHook` must follow this convetion or will fail miserably\n      this.hookOut = this.useHook(...this.args);\n\n      // Checked only on first 'master' render\n      useMemo(() => {\n        if (!Array.isArray(this.hookOut)) {\n          throw new Error(\"[Hookleton] provided 'useHook' must return array values\");\n        }\n      }, []);\n\n      // prevent Exception on 'master' unmount\n      useEffect(() => () => (this.hookOut[1] = this.unmountedSingleton), []);\n\n      // Update 'slaves' when state changed\n      return this.useOnStateChange(initial);\n    }\n\n    return this.useOnSlaveRender(initial);\n  }\n\n  // Here we use a custom function `updateSlaves` that ignore first render call.\n  useOnStateChange() {\n    useEffect(this.__updateSlaves.bind(this), [this.hookOut[0]]);\n    return this.hookOut;\n  }\n\n  useOnSlaveRender() {\n    // Get slave 'updater' for, later, force render it.\n    // Slave state is ignore because we have only one state set in 'master\n    const [, updater] = useState();\n\n    useEffect(() => {\n      // a Map of key/value: updater/updater is useful for some kinds of hooks composed on top of `useFn`\n      this.slaves.set(updater, wrapUpdater(updater));\n      return () => this.slaves.delete(updater); // on unmount\n    }, []);\n\n    return this.hookOut;\n  }\n\n  _onInit(isMaster) {\n    this._onInit = () => {};\n    isMaster.current = true;\n  }\n\n  _updateSlaves() {\n    // State, `hookOut[0]`, is passed to slaves updater. This value is not use here,\n    // but could be useful for libs that extends Hookleton\n    this.slaves.forEach(updater => updater(this.hookOut[0]));\n  }\n\n  __updateSlaves() {\n    // skip first(unexpected) callback call\n    this.__updateSlaves = this._updateSlaves;\n  }\n\n  _get() {\n    return this.hookOut;\n  }\n\n  // Prevent a Exception get throwed when someone is trying to update a unmounted 'master',\n  // behaviour can be changed with `unmountedSingleton` config setting\n  unmountedSingleton() {\n    console.warn(\"[Hookleton] Singleton it's unmounted\");\n  }\n}\n\n// slaves are updated negating '~' his current state. This force to rerender it\nconst wrapUpdater = updater => () => updater(forceUpdate);\nconst forceUpdate = s => ~s;\n"]},"metadata":{},"sourceType":"module"}