{"ast":null,"code":"import _possibleConstructorReturn from \"@babel/runtime-corejs2/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime-corejs2/helpers/esm/getPrototypeOf\";\nimport _get2 from \"@babel/runtime-corejs2/helpers/esm/get\";\nimport _inherits from \"@babel/runtime-corejs2/helpers/esm/inherits\";\nimport _Array$isArray from \"@babel/runtime-corejs2/core-js/array/is-array\";\nimport _slicedToArray from \"@babel/runtime-corejs2/helpers/esm/slicedToArray\";\nimport _toConsumableArray from \"@babel/runtime-corejs2/helpers/esm/toConsumableArray\";\nimport _Map from \"@babel/runtime-corejs2/core-js/map\";\nimport _classCallCheck from \"@babel/runtime-corejs2/helpers/esm/classCallCheck\";\nimport _createClass from \"@babel/runtime-corejs2/helpers/esm/createClass\";\nimport { useEffect, useMemo, useRef, useState } from 'react';\nexport default function createHook(useHook) {\n  for (var _len = arguments.length, initialArgs = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    initialArgs[_key - 1] = arguments[_key];\n  }\n\n  var hook = new HookletonCore(useHook, initialArgs);\n  var useFn = hook.useFn.bind(hook);\n  useFn.get = hook._get.bind(hook);\n  return useFn;\n}\nexport var HookletonCore =\n/*#__PURE__*/\nfunction () {\n  function HookletonCore(useHook, initialArgs) {\n    _classCallCheck(this, HookletonCore);\n\n    this._useHook = useHook;\n    this._args = initialArgs;\n    this._hookOut = [];\n    this._updaters = new _Map();\n  }\n\n  _createClass(HookletonCore, [{\n    key: \"useFn\",\n    value: function useFn() {\n      var _this = this;\n\n      // First hook call become the 'hookleton'\n      var isFirst = useRef(false);\n      useMemo(function () {\n        return _this._onInit(isFirst);\n      }, []); // only one `useFn` instance will be true\n\n      for (var _len2 = arguments.length, initial = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        initial[_key2] = arguments[_key2];\n      }\n\n      if (isFirst.current) {\n        // Set shared `hook` output\n        this._hookOut = this._useHook.apply(this, _toConsumableArray(this._args)); // Checked at start on 'first' render\n\n        this._useCheckHookOut(); // prevent Exception on 'hookleton' unmount\n        // by **CONVENTION** updater is `hookOut[1]\n\n\n        useEffect(function () {\n          return function () {\n            return _this._hookOut[1] = _this._unmountedFirst;\n          };\n        }, []); // Lifecycle hook: `on render first`\n\n        return this.useOnRenderFirst(initial);\n      } // Lifecycle hook: `on render the rest`\n\n\n      return this.useOnRenderRest(initial);\n    } // Here we use a custom function that ignore first render call.\n\n  }, {\n    key: \"useOnRenderFirst\",\n    value: function useOnRenderFirst() {\n      useEffect(this.__updateRest.bind(this), [this._hookOut[0]]);\n      return this._hookOut;\n    }\n  }, {\n    key: \"useOnRenderRest\",\n    value: function useOnRenderRest() {\n      var _this2 = this;\n\n      // Get 'updater' for, later, force render it.\n      // state is ignore because we have only one state set in 'hookleton'\n      var _useState = useState(),\n          _useState2 = _slicedToArray(_useState, 2),\n          updater = _useState2[1];\n\n      useEffect(function () {\n        // a Map of key/value: updater/updater is useful for some kinds of hooks\n        // composed on top of `useFn`\n        _this2._updaters.set(updater, wrapUpdater(updater));\n\n        return function () {\n          return _this2._updaters.delete(updater);\n        }; // on unmount\n      }, []);\n      return this._hookOut;\n    }\n  }, {\n    key: \"_useCheckHookOut\",\n    value: function _useCheckHookOut() {\n      var _this3 = this;\n\n      // Checked at start on 'first' render\n      useMemo(function () {\n        if (!_Array$isArray(_this3._hookOut)) {\n          throw new Error(\"[Hookleton] provided 'useHook' must return array values\");\n        }\n      }, []);\n    }\n  }, {\n    key: \"_onInit\",\n    value: function _onInit(ref) {\n      this._onInit = function () {};\n\n      ref.current = true;\n    }\n  }, {\n    key: \"_updateRest\",\n    value: function _updateRest() {\n      var _this4 = this;\n\n      // State, `hookOut[0]`, is passed to updater. This value is not use here,\n      // but could be useful for libs that extends Hookleton\n      this._updaters.forEach(function (updater) {\n        return updater(_this4._hookOut[0]);\n      });\n    }\n  }, {\n    key: \"__updateRest\",\n    value: function __updateRest() {\n      // skip first(unexpected) callback call\n      this.__updateRest = this._updateRest;\n    }\n  }, {\n    key: \"_get\",\n    value: function _get() {\n      return this._hookOut;\n    } // Prevent a Exception get throwed when someone is trying to update a unmounted 'hookleton',\n\n  }, {\n    key: \"_unmountedFirst\",\n    value: function _unmountedFirst() {\n      console.warn(\"[Hookleton] 'first' was unmounted\");\n    }\n  }]);\n\n  return HookletonCore;\n}();\nexport var Hookleton =\n/*#__PURE__*/\nfunction (_HookletonCore) {\n  _inherits(Hookleton, _HookletonCore);\n\n  function Hookleton() {\n    _classCallCheck(this, Hookleton);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(Hookleton).apply(this, arguments));\n  }\n\n  _createClass(Hookleton, [{\n    key: \"useOnRenderFirst\",\n    value: function useOnRenderFirst(initial) {\n      return _get2(_getPrototypeOf(Hookleton.prototype), \"useOnRenderFirst\", this).call(this, initial).concat({\n        isFirst: true\n      });\n    }\n  }, {\n    key: \"useOnRenderRest\",\n    value: function useOnRenderRest(initial) {\n      return _get2(_getPrototypeOf(Hookleton.prototype), \"useOnRenderRest\", this).call(this, initial).concat({\n        isFirst: false\n      });\n    }\n  }]);\n\n  return Hookleton;\n}(HookletonCore); // Update negating '~' his current state. This force to rerender it\n\nvar wrapUpdater = function wrapUpdater(updater) {\n  return function () {\n    return updater(forceUpdate);\n  };\n};\n\nvar forceUpdate = function forceUpdate(s) {\n  return ~s;\n};","map":{"version":3,"sources":["/Users/flx/Dropbox/Projects/hookleton/example/component/index.js"],"names":["useEffect","useMemo","useRef","useState","createHook","useHook","initialArgs","hook","HookletonCore","useFn","bind","get","_get","_useHook","_args","_hookOut","_updaters","isFirst","_onInit","initial","current","_useCheckHookOut","_unmountedFirst","useOnRenderFirst","useOnRenderRest","__updateRest","updater","set","wrapUpdater","delete","Error","ref","forEach","_updateRest","console","warn","Hookleton","concat","forceUpdate","s"],"mappings":"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","sourcesContent":["import { useEffect, useMemo, useRef, useState } from 'react';\n\nexport default function createHook(useHook, ...initialArgs) {\n  const hook = new HookletonCore(useHook, initialArgs);\n  const useFn = hook.useFn.bind(hook);\n  useFn.get = hook._get.bind(hook);\n  return useFn;\n}\n\nexport class HookletonCore {\n  constructor(useHook, initialArgs) {\n    this._useHook = useHook;\n    this._args = initialArgs;\n\n    this._hookOut = [];\n    this._updaters = new Map();\n  }\n\n  useFn(...initial) {\n    // First hook call become the 'hookleton'\n    const isFirst = useRef(false);\n    useMemo(() => this._onInit(isFirst), []); // only one `useFn` instance will be true\n\n    if (isFirst.current) {\n      // Set shared `hook` output\n      this._hookOut = this._useHook(...this._args);\n\n      // Checked at start on 'first' render\n      this._useCheckHookOut();\n\n      // prevent Exception on 'hookleton' unmount\n      // by **CONVENTION** updater is `hookOut[1]\n      useEffect(() => () => (this._hookOut[1] = this._unmountedFirst), []);\n\n      // Lifecycle hook: `on render first`\n      return this.useOnRenderFirst(initial);\n    }\n\n    // Lifecycle hook: `on render the rest`\n    return this.useOnRenderRest(initial);\n  }\n\n  // Here we use a custom function that ignore first render call.\n  useOnRenderFirst() {\n    useEffect(this.__updateRest.bind(this), [this._hookOut[0]]);\n    return this._hookOut;\n  }\n\n  useOnRenderRest() {\n    // Get 'updater' for, later, force render it.\n    // state is ignore because we have only one state set in 'hookleton'\n    const [, updater] = useState();\n\n    useEffect(() => {\n      // a Map of key/value: updater/updater is useful for some kinds of hooks\n      // composed on top of `useFn`\n      this._updaters.set(updater, wrapUpdater(updater));\n      return () => this._updaters.delete(updater); // on unmount\n    }, []);\n\n    return this._hookOut;\n  }\n\n  _useCheckHookOut() {\n    // Checked at start on 'first' render\n    useMemo(() => {\n      if (!Array.isArray(this._hookOut)) {\n        throw new Error(\"[Hookleton] provided 'useHook' must return array values\");\n      }\n    }, []);\n  }\n\n  _onInit(ref) {\n    this._onInit = () => {};\n    ref.current = true;\n  }\n\n  _updateRest() {\n    // State, `hookOut[0]`, is passed to updater. This value is not use here,\n    // but could be useful for libs that extends Hookleton\n    this._updaters.forEach(updater => updater(this._hookOut[0]));\n  }\n\n  __updateRest() {\n    // skip first(unexpected) callback call\n    this.__updateRest = this._updateRest;\n  }\n\n  _get() {\n    return this._hookOut;\n  }\n\n  // Prevent a Exception get throwed when someone is trying to update a unmounted 'hookleton',\n  _unmountedFirst() {\n    console.warn(\"[Hookleton] 'first' was unmounted\");\n  }\n}\n\nexport class Hookleton extends HookletonCore {\n  useOnRenderFirst(initial) {\n    return super.useOnRenderFirst(initial).concat({ isFirst: true });\n  }\n\n  useOnRenderRest(initial) {\n    return super.useOnRenderRest(initial).concat({ isFirst: false });\n  }\n}\n\n// Update negating '~' his current state. This force to rerender it\nconst wrapUpdater = updater => () => updater(forceUpdate);\nconst forceUpdate = s => ~s;\n"]},"metadata":{},"sourceType":"module"}