{"version":3,"file":"react.js","sources":["../src/util.js","../src/integrations/react.js","../src/index.js"],"sourcesContent":["// Bind an object/factory of actions to the store and wrap them.\nexport function mapActions(actions, store) {\n\tif (typeof actions==='function') actions = actions(store);\n\tlet mapped = {};\n\tfor (let i in actions) {\n\t\tmapped[i] = store.action(actions[i]);\n\t}\n\treturn mapped;\n}\n\n\n// select('foo,bar') creates a function of the form: ({ foo, bar }) => ({ foo, bar })\nexport function select(properties) {\n\tif (typeof properties==='string') properties = properties.split(/\\s*,\\s*/);\n\treturn state => {\n\t\tlet selected = {};\n\t\tfor (let i=0; i<properties.length; i++) {\n\t\t\tselected[properties[i]] = state[properties[i]];\n\t\t}\n\t\treturn selected;\n\t};\n}\n\n\n// Lighter Object.assign stand-in\nexport function assign(obj, props) {\n\tfor (let i in props) obj[i] = props[i];\n\treturn obj;\n}\n","import { createElement, Children, Component } from 'react';\nimport { assign, mapActions, select } from '../util';\n\nconst CONTEXT_TYPES = {\n\tstore: () => {}\n};\n\n/** Wire a component up to the store. Passes state as props, re-renders on change.\n *  @param {Function|Array|String} mapStateToProps  A function mapping of store state to prop values, or an array/CSV of properties to map.\n *  @param {Function|Object} [actions] \t\t\t\tAction functions (pure state mappings), or a factory returning them. Every action function gets current state as the first parameter and any other params next\n *  @returns {Component} ConnectedComponent\n *  @example\n *    const Foo = connect('foo,bar')( ({ foo, bar }) => <div /> )\n *  @example\n *    const actions = { someAction }\n *    const Foo = connect('foo,bar', actions)( ({ foo, bar, someAction }) => <div /> )\n *  @example\n *    @connect( state => ({ foo: state.foo, bar: state.bar }) )\n *    export class Foo { render({ foo, bar }) { } }\n */\nexport function connect(mapStateToProps, actions) {\n\tif (typeof mapStateToProps!=='function') {\n\t\tmapStateToProps = select(mapStateToProps || []);\n\t}\n\treturn Child => {\n\t\tfunction Wrapper(props, context) {\n\t\t\tComponent.call(this, props, context);\n\t\t\tlet { store } = context;\n\t\t\tlet state = mapStateToProps(store ? store.getState() : {}, props);\n\t\t\tlet boundActions = actions ? mapActions(actions, store) : { store };\n\t\t\tlet update = () => {\n\t\t\t\tlet mapped = mapStateToProps(store ? store.getState() : {}, this.props);\n\t\t\t\tfor (let i in mapped) if (mapped[i]!==state[i]) {\n\t\t\t\t\tstate = mapped;\n\t\t\t\t\treturn this.forceUpdate();\n\t\t\t\t}\n\t\t\t\tfor (let i in state) if (!(i in mapped)) {\n\t\t\t\t\tstate = mapped;\n\t\t\t\t\treturn this.forceUpdate();\n\t\t\t\t}\n\t\t\t};\n\t\t\tthis.componentWillReceiveProps = update;\n\t\t\tthis.componentDidMount = () => {\n\t\t\t\tstore.subscribe(update);\n\t\t\t};\n\t\t\tthis.componentWillUnmount = () => {\n\t\t\t\tstore.unsubscribe(update);\n\t\t\t};\n\t\t\tthis.render = () => createElement(Child, assign(assign(assign({}, boundActions), this.props), state));\n\t\t}\n\t\tWrapper.contextTypes = CONTEXT_TYPES;\n\t\treturn (Wrapper.prototype = Object.create(Component.prototype)).constructor = Wrapper;\n\t};\n}\n\n\n/** Provider exposes a store (passed as `props.store`) into context.\n *\n *  Generally, an entire application is wrapped in a single `<Provider>` at the root.\n *  @class\n *  @extends Component\n *  @param {Object} props\n *  @param {Store} props.store\t\tA {Store} instance to expose via context.\n */\nexport class Provider extends Component {\n\tgetChildContext() {\n\t\treturn { store: this.props.store };\n\t}\n\trender() {\n\t\treturn Children.only(this.props.children);\n\t}\n}\nProvider.childContextTypes = CONTEXT_TYPES;\n","import { assign } from './util';\n\n/**\n * Creates a new store, which is a tiny evented state container.\n * @name createStore\n * @param {Object} [state={}]\t\tOptional initial state\n * @returns {store}\n * @example\n * let store = createStore();\n * store.subscribe( state => console.log(state) );\n * store.setState({ a: 'b' });   // logs { a: 'b' }\n * store.setState({ c: 'd' });   // logs { a: 'b', c: 'd' }\n */\nexport default function createStore(state) {\n\tlet listeners = [];\n\tstate = state || {};\n\n\tfunction unsubscribe(listener) {\n\t\tlet out = [];\n\t\tfor (let i=0; i<listeners.length; i++) {\n\t\t\tif (listeners[i]===listener) {\n\t\t\t\tlistener = null;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tout.push(listeners[i]);\n\t\t\t}\n\t\t}\n\t\tlisteners = out;\n\t}\n\n\tfunction setState(update, overwrite, action) {\n\t\tstate = overwrite ? update : assign(assign({}, state), update);\n\t\tlet currentListeners = listeners;\n\t\tfor (let i=0; i<currentListeners.length; i++) currentListeners[i](state, action);\n\t}\n\n\t/**\n\t * An observable state container, returned from {@link createStore}\n\t * @name store\n\t */\n\n\treturn /** @lends store */ {\n\n\t\t/**\n\t\t * Create a bound copy of the given action function.\n\t\t * The bound returned function invokes action() and persists the result back to the store.\n\t\t * If the return value of `action` is a Promise, the resolved value will be used as state.\n\t\t * @param {Function} action\tAn action of the form `action(state, ...args) -> stateUpdate`\n\t\t * @returns {Function} boundAction()\n\t\t */\n\t\taction(action) {\n\t\t\tfunction apply(result) {\n\t\t\t\tsetState(result, false, action);\n\t\t\t}\n\n\t\t\t// Note: perf tests verifying this implementation: https://esbench.com/bench/5a295e6299634800a0349500\n\t\t\treturn function() {\n\t\t\t\tlet args = [state];\n\t\t\t\tfor (let i=0; i<arguments.length; i++) args.push(arguments[i]);\n\t\t\t\tlet ret = action.apply(this, args);\n\t\t\t\tif (ret!=null) {\n\t\t\t\t\tif (ret.then) return ret.then(apply);\n\t\t\t\t\treturn apply(ret);\n\t\t\t\t}\n\t\t\t};\n\t\t},\n\n\t\t/**\n\t\t * Apply a partial state object to the current state, invoking registered listeners.\n\t\t * @param {Object} update\t\t\t\tAn object with properties to be merged into state\n\t\t * @param {Boolean} [overwrite=false]\tIf `true`, update will replace state instead of being merged into it\n\t\t */\n\t\tsetState,\n\n\t\t/**\n\t\t * Register a listener function to be called whenever state is changed. Returns an `unsubscribe()` function.\n\t\t * @param {Function} listener\tA function to call when state changes. Gets passed the new state.\n\t\t * @returns {Function} unsubscribe()\n\t\t */\n\t\tsubscribe(listener) {\n\t\t\tlisteners.push(listener);\n\t\t\treturn () => { unsubscribe(listener); };\n\t\t},\n\n\t\t/**\n\t\t * Remove a previously-registered listener function.\n\t\t * @param {Function} listener\tThe callback previously passed to `subscribe()` that should be removed.\n\t\t * @function\n\t\t */\n\t\tunsubscribe,\n\n\t\t/**\n\t\t * Retrieve the current state object.\n\t\t * @returns {Object} state\n\t\t */\n\t\tgetState() {\n\t\t\treturn state;\n\t\t}\n\t};\n}\n"],"names":["assign","obj","props","let","i","const","CONTEXT_TYPES","store","Provider","getChildContext","this","render","Children","only","children","Component","childContextTypes","state","listeners","unsubscribe","listener","out","length","push","setState","update","overwrite","action","currentListeners","apply","result","args","arguments","ret","then","subscribe","getState","mapStateToProps","actions","properties","split","selected","Child","Wrapper","context","call","boundActions","mapped","mapActions","forceUpdate","componentWillReceiveProps","componentDidMount","componentWillUnmount","createElement","contextTypes","prototype","Object","create","constructor"],"mappings":"uBAyBA,SAAgBA,EAAOC,EAAKC,GAC3B,IAAKC,IAAIC,KAAKF,EAAOD,EAAIG,GAAKF,EAAME,GACpC,OAAOH,ECxBRI,IAAMC,GACLC,oBA4DD,IAAaC,mJACZC,2BACC,OAASF,MAAOG,KAAKR,MAAMK,oBAE5BI,kBACC,OAAOC,WAASC,KAAKH,KAAKR,MAAMY,cALJC,aAQ9BP,EAASQ,kBAAoBV,sBC3Dd,SAAqBW,GACnCd,IAAIe,KAGJ,SAASC,EAAYC,GAEpB,IADAjB,IAAIkB,KACKjB,EAAE,EAAGA,EAAEc,EAAUI,OAAQlB,IAC7Bc,EAAUd,KAAKgB,EAClBA,EAAW,KAGXC,EAAIE,KAAKL,EAAUd,IAGrBc,EAAYG,EAGb,SAASG,EAASC,EAAQC,EAAWC,GACpCV,EAAQS,EAAYD,EAASzB,EAAOA,KAAWiB,GAAQQ,GAEvD,IADAtB,IAAIyB,EAAmBV,EACdd,EAAE,EAAGA,EAAEwB,EAAiBN,OAAQlB,IAAKwB,EAAiBxB,GAAGa,EAAOU,GAQ1E,OA1BAV,EAAQA,OAmCPU,gBAAOA,GACN,SAASE,EAAMC,GACdN,EAASM,GAAQ,EAAOH,GAIzB,OAAO,WAEN,oBADII,GAAQd,GACHb,EAAE,EAAGA,EAAE4B,UAAUV,OAAQlB,IAAK2B,EAAKR,KAAKS,EAAU5B,IAC3DD,IAAI8B,EAAMN,EAAOE,MAAMnB,KAAMqB,GAC7B,GAAS,MAALE,EACH,OAAIA,EAAIC,KAAaD,EAAIC,KAAKL,GACvBA,EAAMI,cAUhBT,EAOAW,mBAAUf,GAET,OADAF,EAAUK,KAAKH,cACAD,EAAYC,iBAQ5BD,EAMAiB,oBACC,OAAOnB,wCD5EV,SAAwBoB,EAAiBC,GDRzC,IAAuBC,ECYtB,MAH6B,mBAAlBF,IDRa,iBADFE,ECUIF,SDTQE,EAAaA,EAAWC,MAAM,YCS/DH,WDRMpB,GAEN,IADAd,IAAIsC,KACKrC,EAAE,EAAGA,EAAEmC,EAAWjB,OAAQlB,IAClCqC,EAASF,EAAWnC,IAAMa,EAAMsB,EAAWnC,IAE5C,OAAOqC,aCKDC,GACN,SAASC,EAAQzC,EAAO0C,cACvB7B,YAAU8B,KAAKnC,KAAMR,EAAO0C,GAC5B,IAAMrC,UACFU,EAAQoB,EAAgB9B,EAAQA,EAAM6B,cAAiBlC,GACvD4C,EAAeR,ED5Bf,SAAoBA,EAAS/B,GACd,mBAAV+B,IAAsBA,EAAUA,EAAQ/B,IACnDJ,IAAI4C,KACJ,IAAK5C,IAAIC,KAAKkC,EACbS,EAAO3C,GAAKG,EAAMoB,OAAOW,EAAQlC,IAElC,OAAO2C,ECsBwBC,CAAWV,EAAS/B,UAAWA,GACxDkB,aACHtB,IAAI4C,EAASV,EAAgB9B,EAAQA,EAAM6B,cAAiB1B,EAAKR,OACjE,IAAKC,IAAIC,KAAK2C,EAAQ,GAAIA,EAAO3C,KAAKa,EAAMb,GAE3C,OADAa,EAAQ8B,EACDrC,EAAKuC,cAEb,IAAK9C,IAAIC,KAAKa,EAAO,KAAMb,KAAK2C,GAE/B,OADA9B,EAAQ8B,EACDrC,EAAKuC,eAGdvC,KAAKwC,0BAA4BzB,EACjCf,KAAKyC,6BACJ5C,EAAM4B,UAAUV,IAEjBf,KAAK0C,gCACJ7C,EAAMY,YAAYM,IAEnBf,KAAKC,yBAAe0C,gBAAcX,EAAO1C,EAAOA,EAAOA,KAAW8C,GAAepC,EAAKR,OAAQe,KAG/F,OADA0B,EAAQW,aAAehD,GACfqC,EAAQY,UAAYC,OAAOC,OAAO1C,YAAUwC,YAAYG,YAAcf"}