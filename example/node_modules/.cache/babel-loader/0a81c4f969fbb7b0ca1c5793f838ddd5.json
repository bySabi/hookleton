{"ast":null,"code":"import _typeof from \"@babel/runtime-corejs2/helpers/esm/typeof\";\nimport _slicedToArray from \"@babel/runtime-corejs2/helpers/esm/slicedToArray\";\nimport _Array$isArray from \"@babel/runtime-corejs2/core-js/array/is-array\";\nimport _Map from \"@babel/runtime-corejs2/core-js/map\";\nimport { useCallback, useEffect, useMemo, useRef, useState } from 'react';\nimport { isArray } from 'util';\nexport function createHookleton(useHook) {\n  for (var _len = arguments.length, initialArgs = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    initialArgs[_key - 1] = arguments[_key];\n  }\n\n  return createHookletonWithConfig.apply(void 0, [{}, useHook].concat(initialArgs));\n}\nexport function createHookletonWithConfig() {\n  var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  var useHook = arguments.length > 1 ? arguments[1] : undefined;\n\n  for (var _len2 = arguments.length, initialArgs = new Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {\n    initialArgs[_key2 - 2] = arguments[_key2];\n  }\n\n  // config defaults\n  var useSlave = config.useSlave || useState; // inject hook for, Ex: debugging\n\n  var useRenderAll = config.renderAllHook || useEffect; // could be: ( useEffect | useLayoutEffect | use??? )\n\n  var unmountedSingleton = config.unmountedSingleton || unmountedSingletonWarn;\n  var ignoredSingletonPredicate = config.ignoredSingletonPredicate || !!config.enableSingletonPredicateWarn // default 'false'\n  ? ignoredSingletonPredicateWarn : ignoredSingletonPredicateSilent;\n  var combineUpdater = !!config.disablePredicates // default 'false'\n  ? withoutPredicate : withPredicate;\n  var hookOut;\n  var slaves = new _Map();\n\n  var _renderSlaves = function renderSlaves() {\n    // skip first(unexpected) 'useRenderAll' callback call\n    _renderSlaves = function renderSlaves(s) {\n      return slaves.forEach(function (updater) {\n        return updater(s);\n      });\n    };\n  };\n\n  var fun = function fun(updater) {\n    return function (p) {\n      return slaves.set(updater, combineUpdater(updater, p));\n    };\n  };\n\n  var isReadyMaster = false; // 'master' initialized status\n  // Custom React Hook\n\n  var hookFn = function hookFn(predicate) {\n    // Initialize 'master' and 'slaves'\n    var isMaster = useRef(false);\n    useMemo(function () {\n      if (!isMaster.current) {\n        if (!isReadyMaster) {\n          isMaster.current = true;\n          isReadyMaster = true;\n        }\n      }\n    }, []); // Update state, only 'master' can\n\n    if (isMaster.current) {\n      hookOut = useHook.apply(void 0, initialArgs); // state = hookOut[0] | updater = hookOut[1]\n      // Checked on first 'master' rendered\n\n      useMemo(function () {\n        if (!_Array$isArray(hookOut)) {\n          throw new Error(\"[Hookleton] provided 'useHook' must return array values\");\n        }\n      }, []); // 'master' always render, that's why predicate is ignored\n\n      hookOut.push(ignoredSingletonPredicate); // ON mount|unmount\n\n      useEffect(function () {\n        return function () {\n          return hookOut[1] = unmountedSingleton;\n        };\n      }, []); // Force render 'slaves' when state has changed\n\n      useRenderAll(function () {\n        return _renderSlaves(hookOut[0]);\n      }, [hookOut[0]]);\n    } else {\n      var _useSlave = useSlave(),\n          _useSlave2 = _slicedToArray(_useSlave, 2),\n          slaveUpdater = _useSlave2[1]; // save updater for later force render 'slaves'\n      // Function that combine predicate & updater for store it on 'slaves' Map\n      //setPredicate = useMemo(p => slaves.set(slaveUpdater, combineUpdater(slaveUpdater, p)), []);\n\n\n      hookOut[hookOut.length - 1] = fun(slaveUpdater); //setPredicate = useMemo(fun(slaveUpdater), [])\n      // ON mount|unmount\n\n      useEffect(function () {\n        //setPredicate(predicate); // combine 'slaveUpdater' with initial 'predicate' Hook parameter\n        fun(slaveUpdater)(predicate);\n        return function () {\n          return slaves.delete(slaveUpdater);\n        };\n      }, []);\n      useState();\n      useState();\n    } // useHook out is untounched, is an array of any length. 'setPredicate' is appended to the end\n\n\n    return hookOut;\n  }; // Inject 'geState' and 'updater' to Hook function object for standalone use, Ex: outside of a Component\n\n\n  hookFn.getState = function () {\n    return hookOut[0];\n  };\n\n  hookFn.updater = function () {\n    return hookOut[1];\n  }; /// HEREEE!!!  we need a check\n\n\n  return hookFn;\n} // Prevent a Exception get throwed when someone is trying to update a unmounted 'master',\n// behaviour can be changed with `unmountedSingleton` config setting\n\nfunction unmountedSingletonWarn() {\n  console.warn(\"[Hookleton] it's unmounted\");\n} // Default function use when someone try to setPredicate parameter on the Singleton Hook\n// singleton render can't not be disable or filtered.\n// Returned 'true' value can be useful to check who is the Singleton Hook instance.\n\n\nfunction ignoredSingletonPredicateSilent() {\n  return true;\n} // User can enable ignoredPredicate warning on Singleton\n\n\nfunction ignoredSingletonPredicateWarn() {\n  console.warn(\"[Hookleton] setPredicate it's ignored on singleton\");\n  return true;\n} // Combine 'predicate' on updaters\n\n\nfunction withPredicate(updater, p) {\n  var predicate = validPredicate(p);\n  return function (s) {\n    return predicate(s) && updater(function (u) {\n      return ~u;\n    });\n  };\n} // Use this when a very extreme performance is required, it will save some CPU cycles\n\n\nfunction withoutPredicate(updater) {\n  return function () {\n    return updater(function (u) {\n      return ~u;\n    });\n  };\n}\n\nfunction validPredicate(p) {\n  switch (_typeof(p)) {\n    case 'undefined':\n      return TRUEFN;\n\n    case 'function':\n      return p;\n\n    case 'boolean':\n      return function () {\n        return p;\n      };\n\n    default:\n      console.warn(\"[Hookleton] predicate '\" + p + \"' is not a boolean or function\");\n      return FALSEFN;\n  }\n}\n\nvar TRUEFN = function TRUEFN() {\n  return true;\n};\n\nvar FALSEFN = function FALSEFN() {\n  return false;\n};","map":{"version":3,"sources":["/Users/flx/Dropbox/Projects/hookleton/example/component/index.js"],"names":["useCallback","useEffect","useMemo","useRef","useState","isArray","createHookleton","useHook","initialArgs","createHookletonWithConfig","config","useSlave","useRenderAll","renderAllHook","unmountedSingleton","unmountedSingletonWarn","ignoredSingletonPredicate","enableSingletonPredicateWarn","ignoredSingletonPredicateWarn","ignoredSingletonPredicateSilent","combineUpdater","disablePredicates","withoutPredicate","withPredicate","hookOut","slaves","renderSlaves","s","forEach","updater","fun","p","set","isReadyMaster","hookFn","predicate","isMaster","current","Error","push","slaveUpdater","length","delete","getState","console","warn","validPredicate","u","TRUEFN","FALSEFN"],"mappings":"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","sourcesContent":["import { useCallback, useEffect, useMemo, useRef, useState } from 'react';\nimport { isArray } from 'util';\n\nexport function createHookleton(useHook, ...initialArgs) {\n  return createHookletonWithConfig({}, useHook, ...initialArgs);\n}\n\nexport function createHookletonWithConfig(config = {}, useHook, ...initialArgs) {\n  // config defaults\n  const useSlave = config.useSlave || useState; // inject hook for, Ex: debugging\n  const useRenderAll = config.renderAllHook || useEffect; // could be: ( useEffect | useLayoutEffect | use??? )\n  const unmountedSingleton = config.unmountedSingleton || unmountedSingletonWarn;\n  const ignoredSingletonPredicate = config.ignoredSingletonPredicate || !!config.enableSingletonPredicateWarn // default 'false'\n    ? ignoredSingletonPredicateWarn\n    : ignoredSingletonPredicateSilent;\n  const combineUpdater = !!config.disablePredicates  // default 'false'\n    ? withoutPredicate\n    : withPredicate;\n\n  let hookOut;\n  const slaves = new Map();\n\n  let renderSlaves = () => {\n    // skip first(unexpected) 'useRenderAll' callback call\n    renderSlaves = s => slaves.forEach(updater => updater(s));\n  };\n  const fun = (updater) => (p) => slaves.set(updater, combineUpdater(updater, p))\n\n  let isReadyMaster = false; // 'master' initialized status\n\n  // Custom React Hook\n  const hookFn = predicate => {\n    // Initialize 'master' and 'slaves'\n    const isMaster = useRef(false);\n    useMemo(() => {\n      if (!isMaster.current) {\n        if (!isReadyMaster) {\n          isMaster.current = true;\n          isReadyMaster = true;\n        }\n      }\n    }, []);\n\n    // Update state, only 'master' can\n    if (isMaster.current) {\n      hookOut = useHook(...initialArgs); // state = hookOut[0] | updater = hookOut[1]\n\n      // Checked on first 'master' rendered\n      useMemo(() => {\n        if (!Array.isArray(hookOut)) {\n          throw new Error(\"[Hookleton] provided 'useHook' must return array values\");\n        }\n      }, []);\n    \n      // 'master' always render, that's why predicate is ignored\n      hookOut.push(ignoredSingletonPredicate);\n\n      // ON mount|unmount\n      useEffect(() => () => (hookOut[1] = unmountedSingleton), []);\n\n      // Force render 'slaves' when state has changed\n      useRenderAll(() => renderSlaves(hookOut[0]), [hookOut[0]]);\n    } else {\n      const [, slaveUpdater] = useSlave(); // save updater for later force render 'slaves'\n\n      // Function that combine predicate & updater for store it on 'slaves' Map\n      //setPredicate = useMemo(p => slaves.set(slaveUpdater, combineUpdater(slaveUpdater, p)), []);\n  \n      hookOut[hookOut.length - 1] = fun(slaveUpdater);\n      //setPredicate = useMemo(fun(slaveUpdater), [])\n      \n      // ON mount|unmount\n      useEffect(() => {\n        //setPredicate(predicate); // combine 'slaveUpdater' with initial 'predicate' Hook parameter\n        fun(slaveUpdater)(predicate)\n        return () => slaves.delete(slaveUpdater);\n      }, []);\n      useState();\n      useState()\n    }\n\n    // useHook out is untounched, is an array of any length. 'setPredicate' is appended to the end\n    return hookOut;\n  };\n\n\n  // Inject 'geState' and 'updater' to Hook function object for standalone use, Ex: outside of a Component\n  hookFn.getState = () => hookOut[0];\n  hookFn.updater = () => hookOut[1]; /// HEREEE!!!  we need a check\n\n  return hookFn;\n}\n\n// Prevent a Exception get throwed when someone is trying to update a unmounted 'master',\n// behaviour can be changed with `unmountedSingleton` config setting\nfunction unmountedSingletonWarn() {\n  console.warn(\"[Hookleton] it's unmounted\");\n}\n\n// Default function use when someone try to setPredicate parameter on the Singleton Hook\n// singleton render can't not be disable or filtered.\n// Returned 'true' value can be useful to check who is the Singleton Hook instance.\nfunction ignoredSingletonPredicateSilent() {\n  return true;\n}\n\n// User can enable ignoredPredicate warning on Singleton\nfunction ignoredSingletonPredicateWarn() {\n  console.warn(\"[Hookleton] setPredicate it's ignored on singleton\");\n  return true;\n}\n\n// Combine 'predicate' on updaters\nfunction withPredicate(updater, p) {\n  const predicate = validPredicate(p);\n  return s => predicate(s) && updater(u => ~u);\n}\n\n// Use this when a very extreme performance is required, it will save some CPU cycles\nfunction withoutPredicate(updater) {\n  return () => updater(u => ~u);\n}\n\nfunction validPredicate(p) {\n  switch (typeof p) {\n    case 'undefined':\n      return TRUEFN;\n    case 'function':\n      return p;\n    case 'boolean':\n      return () => p;\n    default:\n      console.warn(\"[Hookleton] predicate '\" + p + \"' is not a boolean or function\");\n      return FALSEFN;\n  }\n}\n\nconst TRUEFN = () => true;\nconst FALSEFN = () => false;\n"]},"metadata":{},"sourceType":"module"}