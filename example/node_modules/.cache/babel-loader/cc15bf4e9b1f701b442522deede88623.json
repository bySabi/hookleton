{"ast":null,"code":"import _typeof from \"@babel/runtime-corejs2/helpers/esm/typeof\";\nimport _slicedToArray from \"@babel/runtime-corejs2/helpers/esm/slicedToArray\";\nimport { useState, useEffect } from 'react';\nimport { createHookletonWithConfig } from './index';\nexport default function createPredicateHook(useHook) {\n  for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    args[_key - 1] = arguments[_key];\n  }\n\n  return createHookletonWithConfig.apply(void 0, [{\n    useSlave: useSlave\n  }, useHook].concat(args));\n}\n\nvar useSlave = function useSlave(_ref, predicate) {\n  var slaves = _ref.slaves,\n      hookOut = _ref.hookOut;\n\n  // Get slave 'updater' for, later, force render it. Slave state is ignore.\n  var _useState = useState(),\n      _useState2 = _slicedToArray(_useState, 2),\n      updater = _useState2[1];\n\n  useEffect(function () {\n    // a Map of key/value: updater/updater\n    slaves.set(updater, withPredicate(updater, predicate));\n    return function () {\n      return slaves.delete(updater);\n    }; // on unmount\n  }, []);\n  return hookOut;\n}; // Combine 'predicate' on updaters\n\n\nfunction withPredicate(updater, p) {\n  var predicate = normalize(p);\n  return function (s) {\n    return predicate(s) && updater(forceUpdate);\n  };\n}\n\nvar forceUpdate = function forceUpdate(s) {\n  return ~s;\n};\n\nfunction normalize(p) {\n  switch (_typeof(p)) {\n    case 'undefined':\n      return TRUEFN;\n\n    case 'function':\n      return p;\n\n    case 'boolean':\n      return function () {\n        return p;\n      };\n\n    default:\n      console.warn(\"[Hookleton] predicate '\" + p + \"' is not boolean or function\");\n      return FALSEFN;\n  }\n}\n\nvar TRUEFN = function TRUEFN() {\n  return true;\n};\n\nvar FALSEFN = function FALSEFN() {\n  return false;\n};","map":{"version":3,"sources":["/Users/flx/Dropbox/Projects/hookleton/example/component/predicateHookleton.js"],"names":["useState","useEffect","createHookletonWithConfig","createPredicateHook","useHook","args","useSlave","predicate","slaves","hookOut","updater","set","withPredicate","delete","p","normalize","s","forceUpdate","TRUEFN","console","warn","FALSEFN"],"mappings":";;AAAA,SAASA,QAAT,EAAmBC,SAAnB,QAAoC,OAApC;AACA,SAASC,yBAAT,QAA0C,SAA1C;AAEA,eAAe,SAASC,mBAAT,CAA6BC,OAA7B,EAA+C;AAAA,oCAANC,IAAM;AAANA,IAAAA,IAAM;AAAA;;AAC5D,SAAOH,yBAAyB,MAAzB,UAA0B;AAAEI,IAAAA,QAAQ,EAARA;AAAF,GAA1B,EAAwCF,OAAxC,SAAoDC,IAApD,EAAP;AACD;;AAED,IAAMC,QAAQ,GAAG,SAAXA,QAAW,OAAsBC,SAAtB,EAAoC;AAAA,MAAjCC,MAAiC,QAAjCA,MAAiC;AAAA,MAAzBC,OAAyB,QAAzBA,OAAyB;;AACnD;AADmD,kBAE/BT,QAAQ,EAFuB;AAAA;AAAA,MAE1CU,OAF0C;;AAInDT,EAAAA,SAAS,CAAC,YAAM;AACd;AACAO,IAAAA,MAAM,CAACG,GAAP,CAAWD,OAAX,EAAoBE,aAAa,CAACF,OAAD,EAAUH,SAAV,CAAjC;AACA,WAAO;AAAA,aAAMC,MAAM,CAACK,MAAP,CAAcH,OAAd,CAAN;AAAA,KAAP,CAHc,CAGuB;AACtC,GAJQ,EAIN,EAJM,CAAT;AAMA,SAAOD,OAAP;AACD,CAXD,C,CAaA;;;AACA,SAASG,aAAT,CAAuBF,OAAvB,EAAgCI,CAAhC,EAAmC;AACjC,MAAMP,SAAS,GAAGQ,SAAS,CAACD,CAAD,CAA3B;AACA,SAAO,UAAAE,CAAC;AAAA,WAAIT,SAAS,CAACS,CAAD,CAAT,IAAgBN,OAAO,CAACO,WAAD,CAA3B;AAAA,GAAR;AACD;;AAED,IAAMA,WAAW,GAAG,SAAdA,WAAc,CAAAD,CAAC;AAAA,SAAI,CAACA,CAAL;AAAA,CAArB;;AAEA,SAASD,SAAT,CAAmBD,CAAnB,EAAsB;AACpB,kBAAeA,CAAf;AACE,SAAK,WAAL;AACE,aAAOI,MAAP;;AACF,SAAK,UAAL;AACE,aAAOJ,CAAP;;AACF,SAAK,SAAL;AACE,aAAO;AAAA,eAAMA,CAAN;AAAA,OAAP;;AACF;AACEK,MAAAA,OAAO,CAACC,IAAR,CAAa,4BAA4BN,CAA5B,GAAgC,8BAA7C;AACA,aAAOO,OAAP;AATJ;AAWD;;AAED,IAAMH,MAAM,GAAG,SAATA,MAAS;AAAA,SAAM,IAAN;AAAA,CAAf;;AACA,IAAMG,OAAO,GAAG,SAAVA,OAAU;AAAA,SAAM,KAAN;AAAA,CAAhB","sourcesContent":["import { useState, useEffect } from 'react';\nimport { createHookletonWithConfig } from './index';\n\nexport default function createPredicateHook(useHook, ...args) {\n  return createHookletonWithConfig({ useSlave }, useHook, ...args);\n}\n\nconst useSlave = ({ slaves, hookOut }, predicate) => {\n  // Get slave 'updater' for, later, force render it. Slave state is ignore.\n  const [, updater] = useState();\n\n  useEffect(() => {\n    // a Map of key/value: updater/updater\n    slaves.set(updater, withPredicate(updater, predicate));\n    return () => slaves.delete(updater); // on unmount\n  }, []);\n\n  return hookOut;\n};\n\n// Combine 'predicate' on updaters\nfunction withPredicate(updater, p) {\n  const predicate = normalize(p);\n  return s => predicate(s) && updater(forceUpdate);\n}\n\nconst forceUpdate = s => ~s;\n\nfunction normalize(p) {\n  switch (typeof p) {\n    case 'undefined':\n      return TRUEFN;\n    case 'function':\n      return p;\n    case 'boolean':\n      return () => p;\n    default:\n      console.warn(\"[Hookleton] predicate '\" + p + \"' is not boolean or function\");\n      return FALSEFN;\n  }\n}\n\nconst TRUEFN = () => true;\nconst FALSEFN = () => false;\n"]},"metadata":{},"sourceType":"module"}