{"ast":null,"code":"import _typeof from \"@babel/runtime-corejs2/helpers/esm/typeof\";\nimport _slicedToArray from \"@babel/runtime-corejs2/helpers/esm/slicedToArray\";\nimport _Array$isArray from \"@babel/runtime-corejs2/core-js/array/is-array\";\nimport _Map from \"@babel/runtime-corejs2/core-js/map\";\nimport { useEffect, useMemo, useRef, useState } from 'react'; // Instance types\n\nvar MASTER = 0;\nvar PREDICATED = 1; // Slave predicated\n\nvar SLAVE = 2;\nexport function createHookleton(useHook) {\n  for (var _len = arguments.length, initialArgs = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    initialArgs[_key - 1] = arguments[_key];\n  }\n\n  return createHookletonWithConfig.apply(void 0, [{}, useHook].concat(initialArgs));\n}\nexport function createHookletonWithConfig() {\n  var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  var useHook = arguments.length > 1 ? arguments[1] : undefined;\n\n  for (var _len2 = arguments.length, initialArgs = new Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {\n    initialArgs[_key2 - 2] = arguments[_key2];\n  }\n\n  // config defaults\n  var useSlave = config.useSlave || useState; // inject hook for, Ex: debugging\n\n  var useRenderAll = config.renderAllHook || useEffect; // could be: ( useEffect | useLayoutEffect | use??? )\n\n  var unmountedSingleton = config.unmountedSingleton || unmountedSingletonWarn;\n  var hookOut;\n  var slaves = new _Map();\n\n  var _renderSlaves = function renderSlaves() {\n    // skip first(unexpected) 'useRenderAll' callback call\n    _renderSlaves = function renderSlaves(s) {\n      return slaves.forEach(function (updater) {\n        return updater(s);\n      });\n    };\n  };\n\n  var setPredicate = function setPredicate(u) {\n    return function (p) {\n      return slaves.set(u, withPredicate(u, p));\n    };\n  };\n\n  var isReadyMaster = false; // 'master' initialized status\n  // Custom React Hook\n\n  var hookFn = function hookFn(predicate) {\n    // Initialize 'master' and 'slaves'\n    var isType = useRef();\n    useMemo(function () {\n      if (!isType.current) {\n        if (!isReadyMaster) {\n          isType.current = MASTER;\n          isReadyMaster = true;\n        } else if (typeof predicate === 'function' || typeof predicate === 'boolean') {\n          isType.current = PREDICATED;\n        } else {\n          isType.current = SLAVE;\n        }\n      }\n    }, []);\n\n    if (isType.current === MASTER) {\n      // Update state, only 'master' can\n      hookOut = useHook.apply(void 0, initialArgs); // state = hookOut[0] | updater = hookOut[1]\n      // Checked on first 'master' render\n\n      useMemo(function () {\n        if (!_Array$isArray(hookOut)) {\n          throw new Error(\"[Hookleton] provided 'useHook' must return array values\");\n        }\n      }, []); // prevent Exception on 'master' unmount\n\n      useEffect(function () {\n        return function () {\n          return hookOut[1] = unmountedSingleton;\n        };\n      }, []); // Force render 'slaves' when state has changed\n\n      useRenderAll(function () {\n        return _renderSlaves(hookOut[0]);\n      }, [hookOut[0]]);\n      return hookOut;\n    } // is a Slave\n\n\n    var _useSlave = useSlave(),\n        _useSlave2 = _slicedToArray(_useSlave, 2),\n        updater = _useSlave2[1]; // save updater for later force render 'slaves'\n\n\n    if (isType.current === SLAVE) {\n      // ON mount|unmount\n      useEffect(function () {\n        slaves.set(updater, withoutPredicate(updater));\n        return function () {\n          return slaves.remove(updater);\n        };\n      }, []);\n      return hookOut; // if not Predicated return shared hookOut\n    } // Is a Predicate\n    /// ON mount|unmount\n\n\n    useEffect(function () {\n      slaves.set(updater, withPredicate(updater, predicate));\n      return function () {\n        return slaves.remove(updater);\n      };\n    }, []); // If slave is Predicated we return a cloned hookOut with a custom setPredicate\n\n    return hookOut.concat(setPredicate(updater));\n  }; // Inject 'geState' and 'updater' to Hook function object for standalone use, Ex: outside of a Component\n\n\n  hookFn.getState = function () {\n    return hookOut[0];\n  };\n\n  hookFn.updater = function (s) {\n    return hookOut[1](s);\n  };\n\n  return hookFn;\n} // Prevent a Exception get throwed when someone is trying to update a unmounted 'master',\n// behaviour can be changed with `unmountedSingleton` config setting\n\nfunction unmountedSingletonWarn() {\n  console.warn(\"[Hookleton] it's unmounted\");\n}\n\nfunction withoutPredicate(updater) {\n  return function () {\n    return updater(function (u) {\n      return ~u;\n    });\n  };\n} // Create a predicated updater\n\n\nfunction withPredicate(updater, p) {\n  var predicate = validPredicate(p);\n  return function (s) {\n    return predicate(s) && updater(function (u) {\n      return ~u;\n    });\n  };\n}\n\nfunction validPredicate(p) {\n  switch (_typeof(p)) {\n    case 'undefined':\n      return TRUEFN;\n\n    case 'function':\n      return p;\n\n    case 'boolean':\n      return function () {\n        return p;\n      };\n\n    default:\n      console.warn(\"[Hookleton] predicate '\" + p + \"' is not boolean or function\");\n      return FALSEFN;\n  }\n}\n\nvar TRUEFN = function TRUEFN() {\n  return true;\n};\n\nvar FALSEFN = function FALSEFN() {\n  return false;\n};","map":{"version":3,"sources":["/Users/flx/Dropbox/Projects/hookleton/example/component/index.js"],"names":["useEffect","useMemo","useRef","useState","MASTER","PREDICATED","SLAVE","createHookleton","useHook","initialArgs","createHookletonWithConfig","config","useSlave","useRenderAll","renderAllHook","unmountedSingleton","unmountedSingletonWarn","hookOut","slaves","renderSlaves","s","forEach","updater","setPredicate","u","p","set","withPredicate","isReadyMaster","hookFn","predicate","isType","current","Error","withoutPredicate","remove","concat","getState","console","warn","validPredicate","TRUEFN","FALSEFN"],"mappings":"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","sourcesContent":["import { useEffect, useMemo, useRef, useState } from 'react';\n\n// Instance types\nconst MASTER = 0;\nconst PREDICATED = 1; // Slave predicated\nconst SLAVE = 2;\n\nexport function createHookleton(useHook, ...initialArgs) {\n  return createHookletonWithConfig({}, useHook, ...initialArgs);\n}\n\nexport function createHookletonWithConfig(config = {}, useHook, ...initialArgs) {\n  // config defaults\n  const useSlave = config.useSlave || useState; // inject hook for, Ex: debugging\n  const useRenderAll = config.renderAllHook || useEffect; // could be: ( useEffect | useLayoutEffect | use??? )\n  const unmountedSingleton = config.unmountedSingleton || unmountedSingletonWarn;\n\n  let hookOut;\n  const slaves = new Map();\n\n  let renderSlaves = () => {\n    // skip first(unexpected) 'useRenderAll' callback call\n    renderSlaves = s => slaves.forEach(updater => updater(s));\n  };\n  const setPredicate = u => p => slaves.set(u, withPredicate(u, p));\n\n  let isReadyMaster = false; // 'master' initialized status\n\n  // Custom React Hook\n  const hookFn = predicate => {\n    // Initialize 'master' and 'slaves'\n    const isType = useRef();\n    useMemo(() => {\n      if (!isType.current) {\n        if (!isReadyMaster) {\n          isType.current = MASTER;\n          isReadyMaster = true;\n        } else if (typeof predicate === 'function' || typeof predicate === 'boolean') {\n          isType.current = PREDICATED;\n        } else {\n          isType.current = SLAVE;\n        }\n      }\n    }, []);\n    \n    if (isType.current === MASTER) {\n      // Update state, only 'master' can\n      hookOut = useHook(...initialArgs); // state = hookOut[0] | updater = hookOut[1]\n\n      // Checked on first 'master' render\n      useMemo(() => {\n        if (!Array.isArray(hookOut)) {\n          throw new Error(\"[Hookleton] provided 'useHook' must return array values\");\n        }\n      }, []);\n\n      // prevent Exception on 'master' unmount\n      useEffect(() => () => (hookOut[1] = unmountedSingleton), []);\n\n      // Force render 'slaves' when state has changed\n      useRenderAll(() => renderSlaves(hookOut[0]), [hookOut[0]]);\n\n      return hookOut;\n    }\n\n    // is a Slave\n    const [, updater] = useSlave(); // save updater for later force render 'slaves'\n    \n    if (isType.current === SLAVE) {\n      // ON mount|unmount\n      useEffect(() => {\n        slaves.set(updater, withoutPredicate(updater));\n        return () => slaves.remove(updater);\n      }, []);\n\n      return hookOut;  // if not Predicated return shared hookOut\n    }\n\n    // Is a Predicate\n    /// ON mount|unmount\n    useEffect(() => {\n      slaves.set(updater, withPredicate(updater, predicate));\n      return () => slaves.remove(updater);\n    }, []);\n    \n    // If slave is Predicated we return a cloned hookOut with a custom setPredicate\n    return hookOut.concat(setPredicate(updater));\n  };\n\n  // Inject 'geState' and 'updater' to Hook function object for standalone use, Ex: outside of a Component\n  hookFn.getState = () => hookOut[0];\n  hookFn.updater = (s) => hookOut[1](s);\n\n  return hookFn;\n}\n\n// Prevent a Exception get throwed when someone is trying to update a unmounted 'master',\n// behaviour can be changed with `unmountedSingleton` config setting\nfunction unmountedSingletonWarn() {\n  console.warn(\"[Hookleton] it's unmounted\");\n}\n\nfunction withoutPredicate(updater) {\n  return () => updater(u => ~u);\n}\n\n// Create a predicated updater\nfunction withPredicate(updater, p) {\n  const predicate = validPredicate(p);\n  return s => predicate(s) && updater(u => ~u);\n}\n\nfunction validPredicate(p) {\n  switch (typeof p) {\n    case 'undefined':\n      return TRUEFN;\n    case 'function':\n      return p;\n    case 'boolean':\n      return () => p;\n    default:\n      console.warn(\"[Hookleton] predicate '\" + p + \"' is not boolean or function\");\n      return FALSEFN;\n  }\n}\n\nconst TRUEFN = () => true;\nconst FALSEFN = () => false;\n"]},"metadata":{},"sourceType":"module"}