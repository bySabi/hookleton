{"ast":null,"code":"import _slicedToArray from \"@babel/runtime-corejs2/helpers/esm/slicedToArray\";\nimport _Array$isArray from \"@babel/runtime-corejs2/core-js/array/is-array\";\nimport _Map from \"@babel/runtime-corejs2/core-js/map\";\nimport { useEffect, useMemo, useRef, useState } from 'react';\nexport function createHookleton(useHook) {\n  for (var _len = arguments.length, initialArgs = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    initialArgs[_key - 1] = arguments[_key];\n  }\n\n  return createHookletonWithConfig.apply(void 0, [{}, useHook].concat(initialArgs));\n}\nexport function createHookletonWithConfig() {\n  var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  var useHook = arguments.length > 1 ? arguments[1] : undefined;\n\n  for (var _len2 = arguments.length, initialArgs = new Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {\n    initialArgs[_key2 - 2] = arguments[_key2];\n  }\n\n  // config defaults\n  var useSlave = config.useSlave || _useSlave;\n  var useRenderSlave = config.useRenderSlave || _useRenderSlave;\n  var unmountedSingleton = config.unmountedSingleton || unmountedSingletonWarn; // Singleton(master) state array shared with slaves\n\n  var hookOut;\n  var slaves = new _Map(); // Is very convenient inject it at this point\n  // This skip first(unexpected) callback call on render\n\n  slaves.updateSlaves = function () {\n    // State, `hookOut[0]`, is passed to slaves updater. This value is not use here,\n    // but could be for libs that extends beyond `createHookleton` defaults\n    slaves.updateSlaves = function () {\n      return slaves.forEach(function (updater) {\n        return updater(hookOut[0]);\n      });\n    };\n  };\n\n  var _setIsMaster = function setIsMaster(isMaster) {\n    _setIsMaster = function setIsMaster() {}; // dummify the setter for next calls\n\n\n    isMaster.current = true; // the first call is always the 'master'\n  }; // Custom React Hook\n\n\n  var useFn = function useFn(initial) {\n    // Initialize 'master' and 'slaves'\n    var isMaster = useRef(false);\n    useMemo(function () {\n      return _setIsMaster(isMaster);\n    }, []); // only one `useFn` instance will be true, 'the master'\n\n    if (isMaster.current) {\n      // Update state, only 'master' can\n      // by **CONVENTION** state is `hookOut[0]` and updater is `hookOut[1]`\n      hookOut = useHook.apply(void 0, initialArgs); // Checked on first 'master' render\n\n      useMemo(function () {\n        if (!_Array$isArray(hookOut)) {\n          throw new Error(\"[Hookleton] provided 'useHook' must return array values\");\n        }\n      }, []); // prevent Exception on 'master' unmount\n\n      useEffect(function () {\n        return function () {\n          return hookOut[1] = unmountedSingleton;\n        };\n      }, []); // Update 'slaves' when state changed\n\n      useRenderSlave({\n        slaves: slaves,\n        hookOut: hookOut\n      });\n      return hookOut;\n    }\n\n    return useSlave({\n      slaves: slaves,\n      hookOut: hookOut\n    }, initial);\n  }; // Inject 'geState' and 'updater', and 'rest', to Hook function object for standalone use,\n  // Ex: outside of a Component\n\n\n  useFn.getState = function () {\n    return hookOut[0];\n  };\n\n  useFn.updater = function (s) {\n    return hookOut[1](s);\n  }; // Will return a opaque 'rest' array of Hook output, empty [] in the worst case\n\n\n  useFn.rest = function () {\n    return hookOut.slice(2, hookOut.length);\n  };\n\n  return useFn;\n} // CAUTION: We don't try to be too much protective with 'slaves' container. Internal Map is\n// exposed for advanced users that need performance. You will have to take care yourself.\n// default 'useRenderSlave'\n// Here we use a custom function `updateSlaves` that ignore first render call.\n\nvar _useRenderSlave = function _useRenderSlave(_ref) {\n  var slaves = _ref.slaves,\n      hookOut = _ref.hookOut;\n  useEffect(slaves.updateSlaves, [hookOut[0]]);\n}; // default 'useSlave'\n\n\nvar _useSlave = function _useSlave(_ref2) {\n  var slaves = _ref2.slaves,\n      hookOut = _ref2.hookOut;\n\n  // Get slave 'updater' for, later, force render it. Slave state is ignore.\n  var _useState = useState(),\n      _useState2 = _slicedToArray(_useState, 2),\n      updater = _useState2[1];\n\n  useEffect(function () {\n    // a Map of key/value: updater/updater is useful for some kinds of hooks composed on top of `useFn`\n    slaves.set(updater, wrapUpdater(updater));\n    return function () {\n      return slaves.delete(updater);\n    }; // on unmount\n  }, []);\n  return hookOut;\n}; // slaves are updated negating '~' current state. This force to rerender it\n\n\nvar wrapUpdater = function wrapUpdater(updater) {\n  return function () {\n    return updater(forceUpdate);\n  };\n};\n\nvar forceUpdate = function forceUpdate(s) {\n  return ~s;\n}; // Prevent a Exception get throwed when someone is trying to update a unmounted 'master',\n// behaviour can be changed with `unmountedSingleton` config setting\n\n\nfunction unmountedSingletonWarn() {\n  console.warn(\"[Hookleton] Singleton it's unmounted\");\n}","map":{"version":3,"sources":["/Users/flx/Dropbox/Projects/hookleton/example/component/index.js"],"names":["useEffect","useMemo","useRef","useState","createHookleton","useHook","initialArgs","createHookletonWithConfig","config","useSlave","_useSlave","useRenderSlave","_useRenderSlave","unmountedSingleton","unmountedSingletonWarn","hookOut","slaves","updateSlaves","forEach","updater","setIsMaster","isMaster","current","useFn","initial","Error","getState","s","rest","slice","length","set","wrapUpdater","delete","forceUpdate","console","warn"],"mappings":"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","sourcesContent":["import { useEffect, useMemo, useRef, useState } from 'react';\n\nexport function createHookleton(useHook, ...initialArgs) {\n  return createHookletonWithConfig({}, useHook, ...initialArgs);\n}\n\nexport function createHookletonWithConfig(config = {}, useHook, ...initialArgs) {\n  // config defaults\n  const useSlave = config.useSlave || _useSlave;\n  const useRenderSlave = config.useRenderSlave || _useRenderSlave;\n  const unmountedSingleton = config.unmountedSingleton || unmountedSingletonWarn;\n\n  // Singleton(master) state array shared with slaves\n  let hookOut;\n  const slaves = new Map();\n\n  // Is very convenient inject it at this point\n  // This skip first(unexpected) callback call on render\n  slaves.updateSlaves = () => {\n    // State, `hookOut[0]`, is passed to slaves updater. This value is not use here,\n    // but could be for libs that extends beyond `createHookleton` defaults\n    slaves.updateSlaves = () => slaves.forEach(updater => updater(hookOut[0]));\n  };\n\n  let setIsMaster = isMaster => {\n    setIsMaster = () => {}; // dummify the setter for next calls\n    isMaster.current = true; // the first call is always the 'master'\n  };\n\n  // Custom React Hook\n  const useFn = initial => {\n    // Initialize 'master' and 'slaves'\n    const isMaster = useRef(false);\n    useMemo(() => setIsMaster(isMaster), []); // only one `useFn` instance will be true, 'the master'\n\n    if (isMaster.current) {\n      // Update state, only 'master' can\n      // by **CONVENTION** state is `hookOut[0]` and updater is `hookOut[1]`\n      hookOut = useHook(...initialArgs); \n\n      // Checked on first 'master' render\n      useMemo(() => {\n        if (!Array.isArray(hookOut)) {\n          throw new Error(\"[Hookleton] provided 'useHook' must return array values\");\n        }\n      }, []);\n\n      // prevent Exception on 'master' unmount\n      useEffect(() => () => (hookOut[1] = unmountedSingleton), []);\n\n      // Update 'slaves' when state changed\n      useRenderSlave({ slaves, hookOut });\n\n      return hookOut;\n    }\n\n    return useSlave({ slaves, hookOut }, initial);\n  };\n\n  // Inject 'geState' and 'updater', and 'rest', to Hook function object for standalone use,\n  // Ex: outside of a Component\n  useFn.getState = () => hookOut[0];\n  useFn.updater = s => hookOut[1](s);\n  // Will return a opaque 'rest' array of Hook output, empty [] in the worst case\n  useFn.rest = () => hookOut.slice(2, hookOut.length);\n\n  return useFn;\n}\n\n// CAUTION: We don't try to be too much protective with 'slaves' container. Internal Map is\n// exposed for advanced users that need performance. You will have to take care yourself.\n\n// default 'useRenderSlave'\n// Here we use a custom function `updateSlaves` that ignore first render call.\nconst _useRenderSlave = ({ slaves, hookOut }) => {\n  useEffect(slaves.updateSlaves, [hookOut[0]]);\n};\n\n// default 'useSlave'\nconst _useSlave = ({ slaves, hookOut }) => {\n  // Get slave 'updater' for, later, force render it. Slave state is ignore.\n  const [, updater] = useState();\n\n  useEffect(() => {\n    // a Map of key/value: updater/updater is useful for some kinds of hooks composed on top of `useFn`\n    slaves.set(updater, wrapUpdater(updater));\n    return () => slaves.delete(updater); // on unmount\n  }, []);\n\n  return hookOut;\n};\n\n// slaves are updated negating '~' current state. This force to rerender it\nconst wrapUpdater = updater => () => updater(forceUpdate);\nconst forceUpdate = s => ~s;\n\n// Prevent a Exception get throwed when someone is trying to update a unmounted 'master',\n// behaviour can be changed with `unmountedSingleton` config setting\nfunction unmountedSingletonWarn() {\n  console.warn(\"[Hookleton] Singleton it's unmounted\");\n}\n"]},"metadata":{},"sourceType":"module"}