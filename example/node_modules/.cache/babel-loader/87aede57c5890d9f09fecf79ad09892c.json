{"ast":null,"code":"import _slicedToArray from \"@babel/runtime-corejs2/helpers/esm/slicedToArray\";\nimport _Array$isArray from \"@babel/runtime-corejs2/core-js/array/is-array\";\nimport _Map from \"@babel/runtime-corejs2/core-js/map\";\nimport { useEffect, useMemo, useRef, useState } from 'react';\nexport function createHookleton(useHook) {\n  for (var _len = arguments.length, initialArgs = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    initialArgs[_key - 1] = arguments[_key];\n  }\n\n  return createHookletonWithConfig.apply(void 0, [{}, useHook].concat(initialArgs));\n}\nexport function createHookletonWithConfig() {\n  var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  var useHook = arguments.length > 1 ? arguments[1] : undefined;\n\n  for (var _len2 = arguments.length, initialArgs = new Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {\n    initialArgs[_key2 - 2] = arguments[_key2];\n  }\n\n  // config defaults\n  var useSlave = config.useSlave || _useSlave;\n  var useUpdateSlaves = config.useUpdateSlaves || useEffect;\n  var unmountedSingleton = config.unmountedSingleton || unmountedSingletonWarn; // Singleton(master) state array shared with slaves\n\n  var hookOut;\n  var slaves = new _Map(); // Is very convenient inject it at this point\n\n  slaves.updateSlaves = function () {\n    // skip first(unexpected) callback call\n    // slaves are updated negating '~' current state. This force to rerender it\n    slaves.updateSlaves = function () {\n      return slaves.forEach(function (updater) {\n        return updater();\n      });\n    };\n  };\n\n  var _setIsMaster = function setIsMaster(isMaster) {\n    _setIsMaster = function setIsMaster() {}; // dummify the setter for next calls\n\n\n    isMaster.current = true; // the first call is always the 'master'\n  }; // Custom React Hook\n\n\n  var useFn = function useFn(initial) {\n    // Initialize 'master' and 'slaves'\n    var isMaster = useRef(false);\n    useMemo(function () {\n      return _setIsMaster(isMaster);\n    }, []); // only one `useFn` instance will be true, 'the master'\n\n    if (isMaster.current) {\n      // Update state, only 'master' can\n      hookOut = useHook.apply(void 0, initialArgs); // state = hookOut[0] .. updater = hookOut[1]\n      // Checked on first 'master' render\n\n      useMemo(function () {\n        if (!_Array$isArray(hookOut)) {\n          throw new Error(\"[Hookleton] provided 'useHook' must return array values\");\n        }\n      }, []); // prevent Exception on 'master' unmount\n\n      useEffect(function () {\n        return function () {\n          return hookOut[1] = unmountedSingleton;\n        };\n      }, []); // Update 'slaves' when state changed. default to `useEffect`\n\n      useUpdateSlaves(slaves.updateSlaves, [hookOut[0]]);\n      return hookOut;\n    }\n\n    return useSlave({\n      slaves: slaves,\n      hookOut: hookOut\n    }, initial);\n  }; // Inject 'geState' and 'updater', and 'rest', to Hook function object for standalone use,\n  // Ex: outside of a Component\n\n\n  useFn.getState = function () {\n    return hookOut[0];\n  };\n\n  useFn.updater = function (s) {\n    return hookOut[1](s);\n  }; // Will return a opaque 'rest' array of Hook output, empty [] in the worst case\n\n\n  useFn.rest = function () {\n    return hookOut.slice(2, hookOut.length);\n  };\n\n  return useFn;\n} // default 'useSlave'\n\nvar _useSlave = function _useSlave(_ref) {\n  var slaves = _ref.slaves,\n      hookOut = _ref.hookOut;\n\n  // Get slave 'updater' for, later, force render it. Slave state is ignore.\n  var _useState = useState(),\n      _useState2 = _slicedToArray(_useState, 2),\n      updater = _useState2[1];\n\n  useEffect(function () {\n    // a Map of key/value: updater/updater is useful for some kinds of hooks composed on top of `useFn`\n    slaves.set(updater, updater);\n    return function () {\n      return slaves.delete(updater);\n    }; // on unmount\n  }, []);\n  return hookOut;\n}; // Prevent a Exception get throwed when someone is trying to update a unmounted 'master',\n// behaviour can be changed with `unmountedSingleton` config setting\n\n\nfunction unmountedSingletonWarn() {\n  console.warn(\"[Hookleton] Singleton it's unmounted\");\n}","map":{"version":3,"sources":["/Users/flx/Dropbox/Projects/hookleton/example/component/index.js"],"names":["useEffect","useMemo","useRef","useState","createHookleton","useHook","initialArgs","createHookletonWithConfig","config","useSlave","_useSlave","useUpdateSlaves","unmountedSingleton","unmountedSingletonWarn","hookOut","slaves","updateSlaves","forEach","updater","setIsMaster","isMaster","current","useFn","initial","Error","getState","s","rest","slice","length","set","delete","console","warn"],"mappings":"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","sourcesContent":["import { useEffect, useMemo, useRef, useState } from 'react';\n\nexport function createHookleton(useHook, ...initialArgs) {\n  return createHookletonWithConfig({}, useHook, ...initialArgs);\n}\n\nexport function createHookletonWithConfig(config = {}, useHook, ...initialArgs) {\n  // config defaults\n  const useSlave = config.useSlave || _useSlave;\n  const useUpdateSlaves = config.useUpdateSlaves || useEffect;\n  const unmountedSingleton = config.unmountedSingleton || unmountedSingletonWarn;\n\n  // Singleton(master) state array shared with slaves\n  let hookOut;\n  const slaves = new Map();\n\n  // Is very convenient inject it at this point\n  slaves.updateSlaves = () => {\n    // skip first(unexpected) callback call\n    // slaves are updated negating '~' current state. This force to rerender it\n    slaves.updateSlaves = () => slaves.forEach(updater => updater());\n  };\n\n  let setIsMaster = isMaster => {\n    setIsMaster = () => {}; // dummify the setter for next calls\n    isMaster.current = true; // the first call is always the 'master'\n  };\n\n  // Custom React Hook\n  const useFn = initial => {\n    // Initialize 'master' and 'slaves'\n    const isMaster = useRef(false);\n    useMemo(() => setIsMaster(isMaster), []); // only one `useFn` instance will be true, 'the master'\n\n    if (isMaster.current) {\n      // Update state, only 'master' can\n      hookOut = useHook(...initialArgs); // state = hookOut[0] .. updater = hookOut[1]\n\n      // Checked on first 'master' render\n      useMemo(() => {\n        if (!Array.isArray(hookOut)) {\n          throw new Error(\"[Hookleton] provided 'useHook' must return array values\");\n        }\n      }, []);\n\n      // prevent Exception on 'master' unmount\n      useEffect(() => () => (hookOut[1] = unmountedSingleton), []);\n\n      // Update 'slaves' when state changed. default to `useEffect`\n      useUpdateSlaves(slaves.updateSlaves, [hookOut[0]]);\n\n      return hookOut;\n    }\n\n    return useSlave({ slaves, hookOut }, initial);\n  };\n\n  // Inject 'geState' and 'updater', and 'rest', to Hook function object for standalone use,\n  // Ex: outside of a Component\n  useFn.getState = () => hookOut[0];\n  useFn.updater = s => hookOut[1](s);\n  // Will return a opaque 'rest' array of Hook output, empty [] in the worst case\n  useFn.rest = () => hookOut.slice(2, hookOut.length);\n\n  return useFn;\n}\n\n// default 'useSlave'\nconst _useSlave = ({ slaves, hookOut }) => {\n  // Get slave 'updater' for, later, force render it. Slave state is ignore.\n  const [, updater] = useState();\n\n  useEffect(() => {\n    // a Map of key/value: updater/updater is useful for some kinds of hooks composed on top of `useFn`\n    slaves.set(updater, updater);\n    return () => slaves.delete(updater); // on unmount\n  }, []);\n\n  return hookOut;\n};\n\n// Prevent a Exception get throwed when someone is trying to update a unmounted 'master',\n// behaviour can be changed with `unmountedSingleton` config setting\nfunction unmountedSingletonWarn() {\n  console.warn(\"[Hookleton] Singleton it's unmounted\");\n}\n"]},"metadata":{},"sourceType":"module"}