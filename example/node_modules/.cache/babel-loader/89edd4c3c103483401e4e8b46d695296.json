{"ast":null,"code":"import _typeof from \"@babel/runtime-corejs2/helpers/esm/typeof\";\nimport _toConsumableArray from \"@babel/runtime-corejs2/helpers/esm/toConsumableArray\";\nimport _slicedToArray from \"@babel/runtime-corejs2/helpers/esm/slicedToArray\";\nimport _Array$isArray from \"@babel/runtime-corejs2/core-js/array/is-array\";\nimport _Map from \"@babel/runtime-corejs2/core-js/map\";\nimport { useEffect, useMemo, useRef, useState } from 'react';\nexport function createHookleton(useHook) {\n  for (var _len = arguments.length, initialArgs = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    initialArgs[_key - 1] = arguments[_key];\n  }\n\n  return createHookletonWithConfig.apply(void 0, [{}, useHook].concat(initialArgs));\n}\nexport function createHookletonWithConfig() {\n  var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  var useHook = arguments.length > 1 ? arguments[1] : undefined;\n\n  for (var _len2 = arguments.length, initialArgs = new Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {\n    initialArgs[_key2 - 2] = arguments[_key2];\n  }\n\n  // config defaults\n  var useSlave = config.useSlave || useState; // inject hook for, Ex: debugging\n\n  var useRenderAll = config.renderAllHook || useEffect; // could be: ( useEffect | useLayoutEffect | use??? )\n\n  var unmountedSingleton = config.unmountedSingleton || unmountedSingletonWarn;\n  var hookOut;\n  var slaves = new _Map();\n\n  var _renderSlaves = function renderSlaves() {\n    // skip first(unexpected) 'useRenderAll' callback call\n    _renderSlaves = function renderSlaves(s) {\n      return slaves.forEach(function (updater) {\n        return updater(s);\n      });\n    };\n  }; //const setPredicate = u => p => slaves.set(u, withPredicate(u, p));\n\n\n  var setPredicate = function setPredicate(u) {\n    console.log('me llaman u');\n    return function (p) {\n      console.log('me llaman p');\n      slaves.set(u, withPredicate(u, p));\n    };\n  };\n\n  var isReadyMaster = false; // 'master' initialized status\n  // Custom React Hook\n\n  var hookFn = function hookFn(predicate) {\n    // Initialize 'master' and 'slaves'\n    var isPredicate = useRef(false);\n    var isMaster = useRef(false);\n    useMemo(function () {\n      if (!isMaster.current) {\n        if (!isReadyMaster) {\n          isMaster.current = true;\n          isReadyMaster = true;\n        } else {\n          isPredicate.current = typeof predicate === 'function' || typeof predicate === 'boolean';\n        }\n      }\n    }, []);\n\n    if (isMaster.current) {\n      // Update state, only 'master' can\n      hookOut = useHook.apply(void 0, initialArgs); // state = hookOut[0] | updater = hookOut[1]\n      // Checked on first 'master' render\n\n      useMemo(function () {\n        if (!_Array$isArray(hookOut)) {\n          throw new Error(\"[Hookleton] provided 'useHook' must return array values\");\n        }\n      }, []); // prevent Exception on 'master' unmount\n\n      useEffect(function () {\n        return function () {\n          return hookOut[1] = unmountedSingleton;\n        };\n      }, []); // Force render 'slaves' when state has changed\n\n      useRenderAll(function () {\n        return _renderSlaves(hookOut[0]);\n      }, [hookOut[0]]);\n      return hookOut;\n    } // is a Slave\n\n\n    var _useSlave = useSlave(),\n        _useSlave2 = _slicedToArray(_useSlave, 2),\n        updater = _useSlave2[1]; // save updater for later force render 'slaves'\n\n\n    if (!isPredicate.current) {\n      // ON mount|unmount\n      useEffect(function () {\n        slaves.set(updater, withoutPredicate(updater));\n        return function () {\n          return slaves.remove(updater);\n        };\n      }, []);\n      return hookOut; // if not Predicated return shared hookOut\n    } // Is a Predicate\n    /// ON mount|unmount\n\n\n    useEffect(function () {\n      slaves.set(updater, withPredicate(updater, predicate));\n      return function () {\n        return slaves.remove(updater);\n      };\n    }, []); // If slave is Predicated we return a cloned hookOut with a custom setPredicate\n\n    return [].concat(_toConsumableArray(hookOut), [setPredicate(updater)]);\n  }; // Inject 'geState' and 'updater' to Hook function object for standalone use, Ex: outside of a Component\n\n\n  hookFn.getState = function () {\n    return hookOut[0];\n  };\n\n  hookFn.updater = function () {\n    return hookOut[1];\n  }; /// HEREEE!!!  we need a check\n\n\n  return hookFn;\n} // Prevent a Exception get throwed when someone is trying to update a unmounted 'master',\n// behaviour can be changed with `unmountedSingleton` config setting\n\nfunction unmountedSingletonWarn() {\n  console.warn(\"[Hookleton] it's unmounted\");\n}\n\nfunction withoutPredicate(updater) {\n  return function () {\n    return updater(function (u) {\n      return ~u;\n    });\n  };\n} // Create a predicated updater\n\n\nfunction withPredicate(updater, p) {\n  var predicate = validPredicate(p);\n  return function (s) {\n    return predicate(s) && updater(function (u) {\n      return ~u;\n    });\n  };\n}\n\nfunction validPredicate(p) {\n  switch (_typeof(p)) {\n    case 'undefined':\n      return TRUEFN;\n\n    case 'function':\n      return p;\n\n    case 'boolean':\n      return function () {\n        return p;\n      };\n\n    default:\n      console.warn(\"[Hookleton] predicate '\" + p + \"' is not boolean or function\");\n      return FALSEFN;\n  }\n}\n\nvar TRUEFN = function TRUEFN() {\n  return true;\n};\n\nvar FALSEFN = function FALSEFN() {\n  return false;\n};","map":{"version":3,"sources":["/Users/flx/Dropbox/Projects/hookleton/example/component/index.js"],"names":["useEffect","useMemo","useRef","useState","createHookleton","useHook","initialArgs","createHookletonWithConfig","config","useSlave","useRenderAll","renderAllHook","unmountedSingleton","unmountedSingletonWarn","hookOut","slaves","renderSlaves","s","forEach","updater","setPredicate","u","console","log","p","set","withPredicate","isReadyMaster","hookFn","predicate","isPredicate","isMaster","current","Error","withoutPredicate","remove","getState","warn","validPredicate","TRUEFN","FALSEFN"],"mappings":"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","sourcesContent":["import { useEffect, useMemo, useRef, useState } from 'react';\n\nexport function createHookleton(useHook, ...initialArgs) {\n  return createHookletonWithConfig({}, useHook, ...initialArgs);\n}\n\nexport function createHookletonWithConfig(config = {}, useHook, ...initialArgs) {\n  // config defaults\n  const useSlave = config.useSlave || useState; // inject hook for, Ex: debugging\n  const useRenderAll = config.renderAllHook || useEffect; // could be: ( useEffect | useLayoutEffect | use??? )\n  const unmountedSingleton = config.unmountedSingleton || unmountedSingletonWarn;\n\n  let hookOut;\n  const slaves = new Map();\n\n  let renderSlaves = () => {\n    // skip first(unexpected) 'useRenderAll' callback call\n    renderSlaves = s => slaves.forEach(updater => updater(s));\n  };\n\n  //const setPredicate = u => p => slaves.set(u, withPredicate(u, p));\n  const setPredicate = u => {\n    console.log('me llaman u')\n    return p => {\n      console.log('me llaman p')\n      slaves.set(u, withPredicate(u, p))\n    }\n  }\n\n  let isReadyMaster = false; // 'master' initialized status\n\n  // Custom React Hook\n  const hookFn = predicate => {\n    // Initialize 'master' and 'slaves'\n    const isPredicate = useRef(false);\n    const isMaster = useRef(false);\n    useMemo(() => {\n      if (!isMaster.current) {\n        if (!isReadyMaster) {\n          isMaster.current = true;\n          isReadyMaster = true;\n        } else {\n          isPredicate.current = \n            typeof predicate === 'function' || typeof predicate === 'boolean';\n        }\n      }\n    }, []);\n    \n    if (isMaster.current) {\n      // Update state, only 'master' can\n      hookOut = useHook(...initialArgs); // state = hookOut[0] | updater = hookOut[1]\n\n      // Checked on first 'master' render\n      useMemo(() => {\n        if (!Array.isArray(hookOut)) {\n          throw new Error(\"[Hookleton] provided 'useHook' must return array values\");\n        }\n      }, []);\n\n      // prevent Exception on 'master' unmount\n      useEffect(() => () => (hookOut[1] = unmountedSingleton), []);\n\n      // Force render 'slaves' when state has changed\n      useRenderAll(() => renderSlaves(hookOut[0]), [hookOut[0]]);\n\n      return hookOut;\n    }\n\n    // is a Slave\n    const [, updater] = useSlave(); // save updater for later force render 'slaves'\n    \n    if (!isPredicate.current) {\n      // ON mount|unmount\n      useEffect(() => {\n        slaves.set(updater, withoutPredicate(updater));\n        return () => slaves.remove(updater);\n      }, []);\n\n      return hookOut;  // if not Predicated return shared hookOut\n    }\n\n    // Is a Predicate\n    /// ON mount|unmount\n    useEffect(() => {\n      slaves.set(updater, withPredicate(updater, predicate));\n      return () => slaves.remove(updater);\n    }, []);\n    \n    // If slave is Predicated we return a cloned hookOut with a custom setPredicate\n    return [...hookOut, setPredicate(updater)];\n  };\n\n  // Inject 'geState' and 'updater' to Hook function object for standalone use, Ex: outside of a Component\n  hookFn.getState = () => hookOut[0];\n  hookFn.updater = () => hookOut[1]; /// HEREEE!!!  we need a check\n\n  return hookFn;\n}\n\n// Prevent a Exception get throwed when someone is trying to update a unmounted 'master',\n// behaviour can be changed with `unmountedSingleton` config setting\nfunction unmountedSingletonWarn() {\n  console.warn(\"[Hookleton] it's unmounted\");\n}\n\nfunction withoutPredicate(updater) {\n  return () => updater(u => ~u);\n}\n\n// Create a predicated updater\nfunction withPredicate(updater, p) {\n  const predicate = validPredicate(p);\n  return s => predicate(s) && updater(u => ~u);\n}\n\nfunction validPredicate(p) {\n  switch (typeof p) {\n    case 'undefined':\n      return TRUEFN;\n    case 'function':\n      return p;\n    case 'boolean':\n      return () => p;\n    default:\n      console.warn(\"[Hookleton] predicate '\" + p + \"' is not boolean or function\");\n      return FALSEFN;\n  }\n}\n\nconst TRUEFN = () => true;\nconst FALSEFN = () => false;\n"]},"metadata":{},"sourceType":"module"}