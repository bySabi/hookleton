{"ast":null,"code":"import _slicedToArray from \"@babel/runtime-corejs2/helpers/esm/slicedToArray\";\nimport _Array$isArray from \"@babel/runtime-corejs2/core-js/array/is-array\";\nimport { useEffect, useMemo, useRef, useState } from 'react';\nexport function createHookleton(useHook) {\n  for (var _len = arguments.length, initialArgs = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    initialArgs[_key - 1] = arguments[_key];\n  }\n\n  return createHookletonWithConfig.apply(void 0, [{}, useHook].concat(initialArgs));\n}\nexport function createHookletonWithConfig() {\n  var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  var useHook = arguments.length > 1 ? arguments[1] : undefined;\n\n  for (var _len2 = arguments.length, initialArgs = new Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {\n    initialArgs[_key2 - 2] = arguments[_key2];\n  }\n\n  // config defaults\n  var unmountedSingleton = config.unmountedSingleton || unmountedSingletonWarn; // Singleton(master) state array shared\n\n  var hookOut;\n\n  var _setIsMaster = function setIsMaster(isMaster) {\n    _setIsMaster = function setIsMaster() {}; // dummify the setter for next calls\n\n\n    isMaster.current = true; // the first call is always the 'master'\n  }; // Custom React Hook\n\n\n  var useFn = function useFn() {\n    var one = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    // Initialize 'master' and 'slaves'\n    var isMaster = useRef(false);\n    useMemo(function () {\n      return _setIsMaster(isMaster);\n    }, []); // only one `useFn` instance will be true, 'the master'\n\n    if (isMaster.current) {\n      // Update state, only 'master' can\n      hookOut = useHook.apply(void 0, initialArgs); // state = hookOut[0] .. updater = hookOut[1]\n      // Checked on first 'master' render\n\n      useMemo(function () {\n        if (!_Array$isArray(hookOut)) {\n          throw new Error(\"[Hookleton] provided 'useHook' must return array values\");\n        }\n      }, []); // prevent Exception on 'master' unmount\n\n      useEffect(function () {\n        return function () {\n          return hookOut[1] = unmountedSingleton;\n        };\n      }, []);\n    }\n\n    console.log('rended');\n    return hookOut;\n  }; // Inject 'geState' and 'updater', and 'rest', to Hook function object for standalone use,\n  // Ex: outside of a Component\n\n\n  useFn.getState = function () {\n    return hookOut[0];\n  };\n\n  useFn.updater = function (s) {\n    return hookOut[1](s);\n  }; // Will return a opaque 'rest' array of Hook output, empty [] in the worst case\n\n\n  useFn.rest = function () {\n    return hookOut.slice(2, hookOut.length);\n  };\n\n  return useFn;\n}\n\nvar useDefaultSlave = function useDefaultSlave(slaves) {\n  // Get slave 'updater' for, later, force render it. Slave state is ignore.\n  var _useState = useState(),\n      _useState2 = _slicedToArray(_useState, 2),\n      updater = _useState2[1];\n\n  useEffect(function () {\n    // a Map of key/value: updater/updater is useful for some kinds of hooks composed on top of `useFn`\n    slaves.set(updater, updater);\n    return function () {\n      return slaves.delete(updater);\n    }; // on unmount\n  }, []);\n}; // We don't try to be too much protective with 'slaves' container. Internal Map is\n// exposed for advanced users that need performance. You will have to take care yourself.\n\n\nfunction useEffectRender(slaves, hookOut) {\n  useEffect(function () {\n    return slaves.renderSlaves();\n  }, [hookOut[0]]); // Force render slaves' when state has changed\n} // Prevent a Exception get throwed when someone is trying to update a unmounted 'master',\n// behaviour can be changed with `unmountedSingleton` config setting\n\n\nfunction unmountedSingletonWarn() {\n  console.warn(\"[Hookleton] Singleton it's unmounted\");\n}","map":{"version":3,"sources":["/Users/flx/Dropbox/Projects/hookleton/example/component/index.js"],"names":["useEffect","useMemo","useRef","useState","createHookleton","useHook","initialArgs","createHookletonWithConfig","config","unmountedSingleton","unmountedSingletonWarn","hookOut","setIsMaster","isMaster","current","useFn","one","Error","console","log","getState","updater","s","rest","slice","length","useDefaultSlave","slaves","set","delete","useEffectRender","renderSlaves","warn"],"mappings":"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","sourcesContent":["import { useEffect, useMemo, useRef, useState } from 'react';\n\nexport function createHookleton(useHook, ...initialArgs) {\n  return createHookletonWithConfig({}, useHook, ...initialArgs);\n}\n\nexport function createHookletonWithConfig(config = {}, useHook, ...initialArgs) {\n  // config defaults\n  const unmountedSingleton = config.unmountedSingleton || unmountedSingletonWarn;\n\n  // Singleton(master) state array shared\n  let hookOut;\n\n  let setIsMaster = isMaster => {\n    setIsMaster = () => {}; // dummify the setter for next calls\n    isMaster.current = true; // the first call is always the 'master'\n  };\n\n  // Custom React Hook\n  const useFn = (one = false) => {\n    // Initialize 'master' and 'slaves'\n    const isMaster = useRef(false);\n    useMemo(() => setIsMaster(isMaster), []); // only one `useFn` instance will be true, 'the master'\n\n    if (isMaster.current) {\n      // Update state, only 'master' can\n      hookOut = useHook(...initialArgs); // state = hookOut[0] .. updater = hookOut[1]\n\n      // Checked on first 'master' render\n      useMemo(() => {\n        if (!Array.isArray(hookOut)) {\n          throw new Error(\"[Hookleton] provided 'useHook' must return array values\");\n        }\n      }, []);\n\n      // prevent Exception on 'master' unmount\n      useEffect(() => () => (hookOut[1] = unmountedSingleton), []);\n\n    }\n    console.log('rended')\n    return hookOut;\n  };\n\n  // Inject 'geState' and 'updater', and 'rest', to Hook function object for standalone use,\n  // Ex: outside of a Component\n  useFn.getState = () => hookOut[0];\n  useFn.updater = s => hookOut[1](s);\n  // Will return a opaque 'rest' array of Hook output, empty [] in the worst case\n  useFn.rest = () => hookOut.slice(2, hookOut.length);\n\n  return useFn;\n}\n\nconst useDefaultSlave = slaves => {\n  // Get slave 'updater' for, later, force render it. Slave state is ignore.\n  const [, updater] = useState();\n\n  useEffect(() => {\n    // a Map of key/value: updater/updater is useful for some kinds of hooks composed on top of `useFn`\n    slaves.set(updater, updater);\n    return () => slaves.delete(updater); // on unmount\n  }, []);\n};\n\n// We don't try to be too much protective with 'slaves' container. Internal Map is\n// exposed for advanced users that need performance. You will have to take care yourself.\nfunction useEffectRender(slaves, hookOut) {\n  useEffect(() => slaves.renderSlaves(), [hookOut[0]]); // Force render slaves' when state has changed\n}\n\n// Prevent a Exception get throwed when someone is trying to update a unmounted 'master',\n// behaviour can be changed with `unmountedSingleton` config setting\nfunction unmountedSingletonWarn() {\n  console.warn(\"[Hookleton] Singleton it's unmounted\");\n}\n"]},"metadata":{},"sourceType":"module"}