{"ast":null,"code":"import _typeof from \"@babel/runtime-corejs2/helpers/esm/typeof\";\nimport _slicedToArray from \"@babel/runtime-corejs2/helpers/esm/slicedToArray\";\nimport _Array$isArray from \"@babel/runtime-corejs2/core-js/array/is-array\";\nimport _Map from \"@babel/runtime-corejs2/core-js/map\";\nimport { useEffect, useMemo, useRef, useState } from 'react';\nexport function createHookleton(useHook) {\n  for (var _len = arguments.length, initialArgs = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    initialArgs[_key - 1] = arguments[_key];\n  }\n\n  return createHookletonWithConfig.apply(void 0, [{}, useHook].concat(initialArgs));\n}\nexport function createHookletonWithConfig() {\n  var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  var useHook = arguments.length > 1 ? arguments[1] : undefined;\n\n  for (var _len2 = arguments.length, initialArgs = new Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {\n    initialArgs[_key2 - 2] = arguments[_key2];\n  }\n\n  // config defaults\n  var useSlave = config.useSlave || useState; // inject hook for, Ex: debugging\n\n  var useRenderAll = config.renderAllHook || useEffect; // could be: ( useEffect | useLayoutEffect | use??? )\n\n  var unmountedSingleton = config.unmountedSingleton || unmountedSingletonWarn;\n\n  var dummySetPredicate = config.dummySetPredicate || function () {};\n\n  var hookOut;\n  var slaves = new _Map();\n\n  var _renderSlaves = function renderSlaves() {\n    // skip first(unexpected) 'useRenderAll' callback call\n    _renderSlaves = function renderSlaves(s) {\n      return slaves.forEach(function (updater) {\n        return updater(s);\n      });\n    };\n  }; //const setPredicate = u => p => slaves.set(u, withPredicate(u, p));\n\n\n  var setPredicate = function setPredicate(u) {\n    console.log('me llaman u');\n    return function (p) {\n      console.log('me llaman p');\n      slaves.set(u, withPredicate(u, p));\n    };\n  };\n\n  var isReadyMaster = false; // 'master' initialized status\n  // Custom React Hook\n\n  var hookFn = function hookFn(predicate) {\n    // Initialize 'master' and 'slaves'\n    var isPredicate = useRef(false);\n    var isMaster = useRef(false);\n    useMemo(function () {\n      if (!isMaster.current) {\n        if (!isReadyMaster) {\n          isMaster.current = true;\n          isReadyMaster = true;\n        } else {\n          isPredicate.current = typeof predicate === 'function' || typeof predicate === 'boolean';\n        }\n      }\n    }, []);\n\n    if (isMaster.current) {\n      // Update state, only 'master' can\n      hookOut = useHook.apply(void 0, initialArgs); // state = hookOut[0] | updater = hookOut[1]\n      // Checked on first 'master' rendered\n\n      useMemo(function () {\n        if (!_Array$isArray(hookOut)) {\n          throw new Error(\"[Hookleton] provided 'useHook' must return array values\");\n        }\n      }, []); // 'master' always render, that's why predicate is ignored. \n\n      hookOut.push(dummySetPredicate); // Force render 'slaves' when state has changed\n\n      useRenderAll(function () {\n        return _renderSlaves(hookOut[0]);\n      }, [hookOut[0]]);\n      return hookOut;\n    } // is a Slave\n\n\n    var _useSlave = useSlave(),\n        _useSlave2 = _slicedToArray(_useSlave, 2),\n        updater = _useSlave2[1]; // save updater for later force render 'slaves'\n\n\n    if (!isPredicate.current) {\n      // ON mount|unmount\n      useEffect(function () {\n        slaves.set(updater, withoutPredicate(updater));\n        return function () {\n          return slaves.remove(updater);\n        };\n      }, []);\n      return hookOut; // if not Predicated return shared hookOut\n    } // Is a Predicate\n    /// ON mount|unmount\n\n\n    useEffect(function () {\n      slaves.set(updater, withPredicate(updater, predicate));\n      return function () {\n        return slaves.remove(updater);\n      };\n    }, []); // If slave is Predicated we return a cloned hookOut with a custom setPredicate\n    // updater in place of `dummyPredicate` injected on 'master' \n\n    var slaveOut = hookOut.slice(0);\n    slaveOut[slaveOut.length - 1] = setPredicate(updater); // replace dummyPredicate\n\n    return slaveOut;\n  }; // Inject 'geState' and 'updater' to Hook function object for standalone use, Ex: outside of a Component\n\n\n  hookFn.getState = function () {\n    return hookOut[0];\n  };\n\n  hookFn.updater = function () {\n    return hookOut[1];\n  }; /// HEREEE!!!  we need a check\n\n\n  return hookFn;\n} // Prevent a Exception get throwed when someone is trying to update a unmounted 'master',\n// behaviour can be changed with `unmountedSingleton` config setting\n\nfunction unmountedSingletonWarn() {\n  console.warn(\"[Hookleton] it's unmounted\");\n}\n\nfunction withoutPredicate(updater) {\n  return function () {\n    return updater(function (u) {\n      return ~u;\n    });\n  };\n} // Create a predicated updater\n\n\nfunction withPredicate(updater, p) {\n  var predicate = validPredicate(p);\n  return function (s) {\n    return predicate(s) && updater(function (u) {\n      return ~u;\n    });\n  };\n}\n\nfunction validPredicate(p) {\n  switch (_typeof(p)) {\n    case 'undefined':\n      return TRUEFN;\n\n    case 'function':\n      return p;\n\n    case 'boolean':\n      return function () {\n        return p;\n      };\n\n    default:\n      console.warn(\"[Hookleton] predicate '\" + p + \"' is not boolean or function\");\n      return FALSEFN;\n  }\n}\n\nvar TRUEFN = function TRUEFN() {\n  return true;\n};\n\nvar FALSEFN = function FALSEFN() {\n  return false;\n};","map":{"version":3,"sources":["/Users/flx/Dropbox/Projects/hookleton/example/component/index.js"],"names":["useEffect","useMemo","useRef","useState","createHookleton","useHook","initialArgs","createHookletonWithConfig","config","useSlave","useRenderAll","renderAllHook","unmountedSingleton","unmountedSingletonWarn","dummySetPredicate","hookOut","slaves","renderSlaves","s","forEach","updater","setPredicate","u","console","log","p","set","withPredicate","isReadyMaster","hookFn","predicate","isPredicate","isMaster","current","Error","push","withoutPredicate","remove","slaveOut","slice","length","getState","warn","validPredicate","TRUEFN","FALSEFN"],"mappings":"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","sourcesContent":["import { useEffect, useMemo, useRef, useState } from 'react';\n\nexport function createHookleton(useHook, ...initialArgs) {\n  return createHookletonWithConfig({}, useHook, ...initialArgs);\n}\n\nexport function createHookletonWithConfig(config = {}, useHook, ...initialArgs) {\n  // config defaults\n  const useSlave = config.useSlave || useState; // inject hook for, Ex: debugging\n  const useRenderAll = config.renderAllHook || useEffect; // could be: ( useEffect | useLayoutEffect | use??? )\n  const unmountedSingleton = config.unmountedSingleton || unmountedSingletonWarn;\n  const dummySetPredicate = config.dummySetPredicate || function(){};\n\n  let hookOut;\n  const slaves = new Map();\n\n  let renderSlaves = () => {\n    // skip first(unexpected) 'useRenderAll' callback call\n    renderSlaves = s => slaves.forEach(updater => updater(s));\n  };\n\n  //const setPredicate = u => p => slaves.set(u, withPredicate(u, p));\n  const setPredicate = u => {\n    console.log('me llaman u')\n    return p => {\n      console.log('me llaman p')\n      slaves.set(u, withPredicate(u, p))\n    }\n  }\n\n\n  let isReadyMaster = false; // 'master' initialized status\n\n  // Custom React Hook\n  const hookFn = predicate => {\n    // Initialize 'master' and 'slaves'\n    const isPredicate = useRef(false);\n    const isMaster = useRef(false);\n    useMemo(() => {\n      if (!isMaster.current) {\n        if (!isReadyMaster) {\n          isMaster.current = true;\n          isReadyMaster = true;\n        } else {\n          isPredicate.current = \n            typeof predicate === 'function' || typeof predicate === 'boolean';\n        }\n      }\n    }, []);\n    \n    if (isMaster.current) {\n      // Update state, only 'master' can\n      hookOut = useHook(...initialArgs); // state = hookOut[0] | updater = hookOut[1]\n\n      // Checked on first 'master' rendered\n      useMemo(() => {\n        if (!Array.isArray(hookOut)) {\n          throw new Error(\"[Hookleton] provided 'useHook' must return array values\");\n        }\n      }, []);\n\n      // 'master' always render, that's why predicate is ignored. \n      hookOut.push(dummySetPredicate);\n    \n      // Force render 'slaves' when state has changed\n      useRenderAll(() => renderSlaves(hookOut[0]), [hookOut[0]]);\n\n      return hookOut;\n    }\n\n    // is a Slave\n    const [, updater] = useSlave(); // save updater for later force render 'slaves'\n    \n    if (!isPredicate.current) {\n      // ON mount|unmount\n      useEffect(() => {\n        slaves.set(updater, withoutPredicate(updater));\n        return () => slaves.remove(updater);\n      }, []);\n\n      return hookOut;  // if not Predicated return shared hookOut\n    }\n\n    // Is a Predicate\n    /// ON mount|unmount\n    useEffect(() => {\n      slaves.set(updater, withPredicate(updater, predicate));\n      return () => slaves.remove(updater);\n    }, []);\n    \n    // If slave is Predicated we return a cloned hookOut with a custom setPredicate\n    // updater in place of `dummyPredicate` injected on 'master' \n    const slaveOut = hookOut.slice(0);\n    slaveOut[slaveOut.length-1] = setPredicate(updater); // replace dummyPredicate\n\n    return slaveOut;\n  };\n\n  // Inject 'geState' and 'updater' to Hook function object for standalone use, Ex: outside of a Component\n  hookFn.getState = () => hookOut[0];\n  hookFn.updater = () => hookOut[1]; /// HEREEE!!!  we need a check\n\n  return hookFn;\n}\n\n// Prevent a Exception get throwed when someone is trying to update a unmounted 'master',\n// behaviour can be changed with `unmountedSingleton` config setting\nfunction unmountedSingletonWarn() {\n  console.warn(\"[Hookleton] it's unmounted\");\n}\n\nfunction withoutPredicate(updater) {\n  return () => updater(u => ~u);\n}\n\n// Create a predicated updater\nfunction withPredicate(updater, p) {\n  const predicate = validPredicate(p);\n  return s => predicate(s) && updater(u => ~u);\n}\n\nfunction validPredicate(p) {\n  switch (typeof p) {\n    case 'undefined':\n      return TRUEFN;\n    case 'function':\n      return p;\n    case 'boolean':\n      return () => p;\n    default:\n      console.warn(\"[Hookleton] predicate '\" + p + \"' is not boolean or function\");\n      return FALSEFN;\n  }\n}\n\nconst TRUEFN = () => true;\nconst FALSEFN = () => false;\n"]},"metadata":{},"sourceType":"module"}